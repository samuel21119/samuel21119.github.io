<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[APCS. 2019/02/16]]></title>
    <url>%2F2019%2F02%2F19%2FAPCS-2019-02-16%2F</url>
    <content type="text"><![CDATA[2019/02/19 APCS實作題詳解及範例程式 pA無確切題目敘述及輸入格式。 pBDescription給定一個長度為$n(1&lt;n\le10^5)$的01字串，計算最長與最短的連續1長度。接著有$k(1 \le k \le 2*10^4)$次操作，每次將一個0改成1。對於每次操作，輸出當前最長與最短的連續1長度(包括一開始輸入的)。 Solution題目中有特別說到保證連續1的長度不超過$10^4$，所以可以用線性做法，不過這裡是考慮到當沒有這個限制時，應該怎麼做。 使用Disjoint Set(並查集)紀錄連通快(相鄰的1為同一塊)，接著用multiset紀錄每個連通塊的大小。對於每次輸入，把該點的兩邊(注意要考慮到可能只有一邊是1的可能)的大小在multiset中去掉，然後用Disjoint Set合併，再將新的大小插入到multiset裡面。輸出的時候輸出set中最大最小值即可。 時間複雜度：$O(n + klogn)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10010;int n, k;int in[maxn];multiset&lt;int&gt; s;struct disjoint_set &#123; int parent[maxn]; int size[maxn]; void init() &#123; for (int i = 0; i &lt;= maxn; i++) &#123; parent[i] = i; size[i] = 1; &#125; &#125; int find(int i) &#123; if (i == parent[i]) return i; return parent[i] = find(parent[i]); &#125; void connect(int a, int b) &#123; int pa = find(a); int pb = find(b); s.erase(s.find(size[pa])); s.erase(s.find(size[pb])); size[pa] += size[pb]; parent[pb] = pa; s.insert(size[pa]); &#125;&#125;ds;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; ds.init(); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; in[i]; if (in[i]) s.insert(1); &#125; for (int i = 2; i &lt;= n; i++) &#123; if (in[i - 1] &amp;&amp; in[i]) &#123; ds.connect(i - 1, i); &#125; &#125; cout &lt;&lt; *s.begin() &lt;&lt; ' ' &lt;&lt; *s.rbegin() &lt;&lt; '\n'; while (k--) &#123; int i; cin &gt;&gt; i; ds.size[i] = 1; s.insert(1); if (i &gt; 1 &amp;&amp; in[i - 1]) ds.connect(i - 1, i); if (i &lt; n &amp;&amp; in[i + 1]) ds.connect(i, i + 1); in[i] = 1; cout &lt;&lt; *s.begin() &lt;&lt; ' ' &lt;&lt; *s.rbegin() &lt;&lt; '\n'; &#125; return 0;&#125; pCDescription給你三個數值函數f,g,h的定義，變數數目各為1,2,3，且保證均為一次函數。輸入一個三者的合成函數但所有括號與逗點都被空白取代，計算該合成函數的值。題目中提示可以用遞迴，並保證不必使用大數運算。 Solution遞迴做下去。由於我沒有f,g,h的係數，所以在程式中會標示為$f0, g0, g1, h0, h1, h2$代表各個係數。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll f0, g[2], h[3];ll toll(string &amp;s) &#123; ll re = 0; for (char &amp;i : s) &#123; re *= 10; re += i - '0'; &#125; return re;&#125;ll calc(char cmd) &#123; string s; ll re = 0; if (cmd == 'f') &#123; cin &gt;&gt; s; if (isdigit(s[0])) re = f0 * toll(s); else re = f0 * calc(s[0]); &#125;else if (cmd == 'g') &#123; for (int i = 0; i &lt; 2; i++) &#123; cin &gt;&gt; s; if (isdigit(s[0])) re += g[i] * toll(s); else re += g[i] * calc(s[0]); &#125; &#125;else for (int i = 0; i &lt; 3; i++) &#123; cin &gt;&gt; s; if (isdigit(s[0])) re += h[i] * toll(s); else re += h[i] * calc(s[0]); &#125; return re;&#125;void init() &#123; // 測試用係數 f0 = 2; g[0] = 1, g[1] = 2; h[0] = 1, h[1] = 3, h[2] = 4;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); // init(); char cmd; cin &gt;&gt; cmd; cout &lt;&lt; calc(cmd) &lt;&lt; '\n'; return 0;&#125; pDDescription給定$n(1&lt;n&lt;2*10^5)$，及長度為$n$的陣列a和b$(0 \le a[i], b[i] \le 10^7)$。$S(i)=i-max(j)-1 使得 a[i]+b[i]&lt;a[j] 且 j&lt;i (若j不存在，則j=0)$。求$\sum_{i=1}^n S(i)$為何。 Solution從前面做到後面，假設當前index為$i$，則可以刪掉一些在$i$之前「不可能為答案」的數字。這樣講解有點抽象，從下面的圖片比較容易懂： 考慮$a[1]\text{~}a[5]$，可以發現$a[2]和a[4]$不可能為答案，因為$a[5]$比這兩個數字都還大。所以可以把灰色部分砍掉，維護一個「遞減陣列」。 而有了這個遞減陣列，就可以利用$a[6]+b[6]$去二分搜，找出最大的j滿足條件。 不過到這裡還沒完，假設$S(i)$算完了，那應該要想辦法把$a[i]$加入該陣列。對於一個現成的遞減陣列，要怎麼加入新的元素？一直檢查該陣列的後面，如果小於$a[i]$，則pop掉，否則就把$a[i]$加到最後面即可。 時間複雜度：$O(nlogn)$ 注意：因為upper_bound預設是用在「遞增陣列」，並非遞減。所以我這裡在upper_bound時使用rbegin和rend，是因為我是維護一個遞減數列，但是upper_bound只適用遞增數列，所以就用反向的iterator來處理。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 200010;int a[maxn], b[maxn];int n;ll ans;struct node &#123; int num, index; node() &#123;&#125; node (int a, int b) &#123; num = a, index = b; &#125; bool operator&lt; (const node &amp;b) const &#123; return num &lt; b.num; &#125;&#125;;vector&lt;node&gt; arr;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= n; i++) &#123; auto ptr = upper_bound(arr.rbegin(), arr.rend(), node(a[i] + b[i], 0)); if (ptr == arr.rend()) ans += i - 1; else ans += i - ptr-&gt;index - 1; while (!arr.empty() &amp;&amp; arr.back().num &lt; a[i]) arr.pop_back(); arr.push_back(&#123;a[i], i&#125;); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Disjoint set</tag>
        <tag>Binary Search</tag>
        <tag>APCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 1427. Parade]]></title>
    <url>%2F2018%2F12%2F11%2FUVa-1427-Parade%2F</url>
    <content type="text"><![CDATA[Description一個城市有n+1個橫向路和m+1個縱向路，一個國王從最北邊的進入，然後沿某種路線從最南邊出去，每小段橫向路都有一個高興值，但國王不會在某條橫向路待超過k分鐘，問國王可以得到的最大的高興值是多少？ Input Format輸入包含多筆測資，第一行為$n\ m\ k$三整數，若$n=m=k=0$則程式結束。接下來有$n+1$行，代表從北到南的東西向道路。 每行有$m$個數字，代表此道路m個區域從西到東的高興值。 再來有$n+1$行，也代表從北到南的東西向道路。 每行有$m$個數字，代表此道路m個區域從西到東的長度。 Output Format每筆測資輸出一行，輸出最大的高興值，答案保證小於$2^{32}$。 Sample Input2 3 27 8 14 5 61 2 31 1 11 1 11 1 10 0 0 Sample Output27 本側資示意圖如下： UVa - 1427 Solution這題很明顯的是DP。但是如果用一般的DP寫，時間複雜度是$O(nm^2)$，會導致TLE，所以需要用優化將其複雜度壓下一個維度。由於這是我第一次寫有關單調隊列的題解，所以在推導過程中可能不會寫得很好。 令$dp[i][j]$為第i行時j點的最大幸福度。則可以轉移式可以寫成如下：$dp[i][j] = max(dp[i][j], dp[i-1][k]+\text{happy_sum}[k\text{~}j]) 且 \text{length_sum}[k\text{~}j] \le K$為了方便計算，令$happy[i]=從0\text{~}i的高興值總和$$len[i]=從0\text{~}i道路長度總和$則可以寫成：$dp[i][j] = max(dp[i][j],\text{ }dp[i-1][k] + happy[j] - happy[k]) 且 len[j] - len[k] \le K$移項得：$(dp[i - 1][k] - happy[k]) + happy[j]$很明顯可以看出可以利用deque，維護$(dp[i - 1][k] - happy[k])$的遞減佇列，並在當最前項$len[j] - len[k] &gt; K$時pop掉，以確保最前項在滿足條件下為最大值。 以上推倒過程只有討論到「左到右」的，實際上還要考慮「右到左」的移動。時間複雜度：$O(nm)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/************************************************************************* &gt; File Name: 01427 - Parade.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Tue Dec 11 09:21:54 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, m;ll dp[2][10010];ll happy[110][10010];ll len[110][10010], k;int dq[10010], l, r;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &amp;&amp; (n || m || k)) &#123; n++; for (int i = n; i; i--) for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; happy[i][j]; happy[i][j] += happy[i][j - 1]; &#125; for (int i = n; i; i--) for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; len[i][j]; len[i][j] += len[i][j - 1]; &#125; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; int now = i &amp; 1; int prev = !now; l = r = 0; for (int j = 0; j &lt;= m; j++) &#123; while (l != r &amp;&amp; len[i][j] - len[i][dq[l]] &gt; k) l++; while (l != r &amp;&amp; dp[prev][j] - happy[i][j] &gt;= dp[prev][dq[r - 1]] - happy[i][dq[r - 1]]) r--; dq[r++] = j; dp[now][j] = dp[prev][dq[l]] - happy[i][dq[l]] + happy[i][j]; &#125; l = r = 0; for (int j = m; j &gt;= 0; j--) &#123; while (l != r &amp;&amp; len[i][dq[l]] - len[i][j] &gt; k) l++; while (l != r &amp;&amp; dp[prev][j] + happy[i][j] &gt;= dp[prev][dq[r - 1]] + happy[i][dq[r - 1]]) r--; dq[r++] = j; dp[now][j] = max(dp[now][j], dp[prev][dq[l]] + happy[i][dq[l]] - happy[i][j]); &#125; &#125; ll ans = 0; for (int i = 0; i &lt;= m; i++) ans = max(ans, dp[n &amp; 1][i]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[107學年度 校內初選題目]]></title>
    <url>%2F2018%2F10%2F25%2F107%E5%AD%B8%E5%B9%B4%E5%BA%A6-%E6%A0%A1%E5%85%A7%E5%88%9D%E9%81%B8%E9%A1%8C%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[前幾天是雄中資訊學科能力競賽初試，而下面是這次競賽的題目，其中有幾題是出自於UVa的。 Problem ADescription給你平面上3個點的座標，請你判斷這三點是否共線。 Input Format輸入含有多筆測資，每筆測資一列，含有6個整數$(x_1 \; y_1 \; x_2 \; y_2 \; x_3 \; y_3)$。分別代表這三個點的x,y座標。每個整數的範圍均介於-10000~10000之間。 Output Format每筆測資輸出一列。如果這三點共線，請輸出&quot;yes&quot;，否則輸出&quot;no&quot;。 Sample Input0 0 1 1 2 21 2 3 5 -1 -10 0 1 2 3 3 Sample Outputyesyesno Problem BDescription這是一種2個人的遊戲。開始的時候有$n$個整數在一個陣列中，兩個玩家A和B輪流去取陣列中的整數。每次每個玩家能夠從陣列的左邊或右邊（但不能同時從左邊和右邊）拿任意個連續的整數（但至少要拿一個）。當所有的整數都被拿完時遊戲即結束。每個玩家得到的分數就是他所拿的那些整數的和。當然，2個玩家都想要贏對方多一些。假如這2個玩家都是「超完美（optimal）」玩家，並且每次遊戲開始時都由 A 先拿，請問當遊戲結束時 A 得到的分數跟 B 得到的分數差是多少？ Input Format輸入含有多組測試資料。每組測試資料的第一列有一個整數$n \; (0 &lt; n \le 100)$ 代表陣列中整數的數目。接下來為$n$個陣列中的整數。 當$n=0$時代表輸入結束。 Output Format對每組測試資料輸出一列，當遊戲結束時 A 得到的分數跟 B 得到的分數差是多少？ Sample Input44 -10 -20 741 2 3 43-10 -20 7105 -10 -20 -40 30 -50 -100 2 -4 -70 Sample Output710-38 UVa - 10891 Problem CDescription這是學二元一次方程式時的經典問題：有一個籠子裡面有雞和兔。已知有$n$個頭，$m$隻腳。請問籠子裡有幾隻雞，幾隻兔？請注意：這裡的雞和兔都是正常的。 Input Format輸入含有多筆測資。每筆測資一列，有2個整數$n,m$。$(1\le n,m &lt;1000)$ Output Format每筆測資輸出一列：有幾隻雞，幾隻兔。如果沒有答案請輸出&quot;no answer&quot; Sample Input5 145 155 16 Sample Output3 2no answer2 3 Problem DDescription一個數被稱為「超級指數」，當它至少是2個不同的正整數的次方(&gt;1)時。例如: 64是超級指數，因為 $64=8^2$，並且$64=4^3$你的任務是找出所有小於$2^{64}$的所有超級指數。 Input Format本題沒有輸入。 Output Format每個超級指數輸出一列，由小到大。前幾個數請見範例輸出。 Sample Output1166481256512... Hint使用unsigned long long共有67385個超級指數 Problem EDescription給你一個僅含有數字的字串，你的任務是在此字串中找出最大的質數。 在本問題中，質數的範圍限定在 2~100000 Input Format輸入含有多筆測資，每筆測資一列。每筆測資含有一字串，僅含有數字且長度最大255當輸入測資為0時，代表輸入結束，本筆測資不須輸出。 Output Format每筆測資輸出字串中出現最大的質數。 Sample Input1124591321150448122640633223310 Sample Output11132123331 UVa - 12542 Problem FDescription一個迴文(palindrome)是指一個字串從左到右和從又到左念起來都一樣。例如: &quot;上海自來水來自海上&quot;，&quot;madam&quot;，&quot;qq&quot; 等都是迴文。給你任一個字串，請你算出要經過多少次「交換」才能把它變成迴文。在這裡「交換」是指將相鄰的2個字元對調。 例如: 字串 &quot;mamad&quot; 可以經由3次交換，使之成為迴文 &quot;madam&quot;，過程如下:把ad交換，字串變成 mamda把md交換，字串變成 madma把ma交換，字串變成 madam Input Format輸入的第一列含有一個整數，代表以下有幾筆測資。每筆測資一列，含有一字串，僅含小寫字元且長度最大100。 Output Format每筆測資輸出一列，經過多少次「交換」才能把輸入字串變成迴文。如果不可能做到，請輸出&quot;Impossible&quot;。 Sample Input3mamadasflkjaabb Sample Output3Impossible2 UVa - 10716 Problem GDescription給你一個含有障礙物及1~9數字的方陣，你可以從任何一個不為障礙物的格子開始走，最後停在某格子。每一步你可以走到上、下、左、右四個鄰居格子其中之一。但是你不可以走到有障礙物的格子，你也不可以走到一個格子超過1次。當你結束時，根據你剛才走過的格子的順序，你會得到一個數字。 請參考下圖： 以這圖片為例，最大數字為791452384。 Input Format輸入含有多筆測資。 每筆測資的第一列，含有2個數字$R,C(2 \le R,C \le 15, R*C\le30)$，代表方陣的高度及長度。接下來的$R$列，每列含有$C$個字元。僅含有#及1~9。#代表該格子為障礙物。方陣中至少會有一個格子為數字1~9。 當$R=C=0$時，代表輸入結束。 Output Format每筆測資輸出一列，輸出你可以走出來最大的數字。 Sample Input3 7##9784###123####45###2 5#3#12#####0 0 Sample Output79145238421 UVa - 11882]]></content>
      <categories>
        <category>題目</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>DFS</tag>
        <tag>Greedy</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 838. Worm World]]></title>
    <url>%2F2018%2F10%2F09%2FUVa-838-Worm-World%2F</url>
    <content type="text"><![CDATA[Description給定一張n*n的圖，每個格子上面都有一個數字。求在不碰到重複數字的情況下，最遠可以走多遠（只能上下左右移動）？ Input Format輸入的第一列有一個整數代表以下有多少組測試資料。每組測試資料的第一列，有一個整數$N(0 &lt; N \le 12)$，代表這方陣的邊長大小。 接下來有$N$列，每列有$N$個整數（均介於 0 到 1000 之間）代表方陣中的數字。第一列與第一組測試資料以及各組測試資料間均有一空白列 Output Format對於每一筆測資請輸出一列，輸出最遠距離為多少。 Sample Input131 2 12 3 43 2 1 Sample Output4 UVa - 838 Solution從uHunt上面看到這題的解題統計，可以發現TLE占非常多數。 所以這題的難度就是在於，如何降低程式執行時間？首先先分析一下這題的做法，很明顯的可以看出可以用DFS來解。 對於每一層遞迴，朝上下左右四個方向去做遞迴，若遇到重複出現的數字就跳出。 然後我們可以再做一下優化： 假設此圖出現$k$個不同的數字，則最長路徑距離應為$k$，所以如果$遞迴深度 \ge k$，則可以$return$。 但是就算做了上述的優化，還是會TLE。結果後來我發現，dfs的順序很重要，「上左下右」跟「上下左右」等其他順序執行出來的時間差很多，到目前為止我還是不能證明出來為何會這樣，但是只要照著「上左下右」的順序去寫就可以輕鬆拿到AC了！ 程式執行結果如下圖： 網路上有人這題使用A*+Heap的作法，但是程式非常冗長且複雜，而且執行時間比我寫的還久一點，所以這裡就不說明了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: 00838 - Worm World.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Tue Oct 2 17:06:29 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;int in[12][12];int d[2][4] = &#123;&#123;-1, 0, 1, 0&#125;, &#123;0, -1, 0, 1&#125;&#125;; //up left down rightbool visit[1001];int ans, cnt, n, t, c, ni, nj, steps;void dfs(int i, int j) &#123; if (ans == cnt) return; visit[in[i][j]] = 0; for (int k = 0; k &lt; 4; k++) &#123; ni = i + d[0][k]; nj = j + d[1][k]; if (nj &lt; 0 || ni &lt; 0 || nj == n || ni == n) continue; if (!visit[in[ni][nj]]) continue; steps++; dfs(ni, nj); steps--; &#125; ans = max(ans, steps); visit[in[i][j]] = 1;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); for (cin &gt;&gt; c; t &lt; c; ) &#123; cin &gt;&gt; n; cnt = ans = 0; memset(visit, 0, sizeof(visit)); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; in[i][j]; if (!visit[in[i][j]]) visit[in[i][j]] = 1, cnt++; &#125;; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) &#123; steps = 1; dfs(i, j); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; if (++t &lt; c) cout &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 10600. ACM contest and Blackout]]></title>
    <url>%2F2018%2F09%2F22%2FUVa-10600-ACM-contest-and-Blackout%2F</url>
    <content type="text"><![CDATA[Description給定一張無向圖，請輸出最小生成樹和次小生成樹的大小。 Input Format第一行會有t，代表有t個測資$(1 &lt; t &lt; 15)$。 接下來每個測資會有N M，代表n個點以及m條邊(3 &lt; N &lt; 100)。 然後會有M行，$a_i b_i v_i$代表第$i$條邊的兩端點以及權重v。 Output Format每組測試資料輸出最小生成樹和次小生成樹大小，中間用一個空格格開。 Sample Input25 81 3 753 4 512 4 193 2 952 5 425 4 311 2 93 5 669 141 2 41 8 82 8 113 2 88 9 78 7 17 9 69 3 23 4 73 6 47 6 24 6 144 5 95 6 10 Sample Output110 12137 37 UVa - 10600 Solution這題搞了兩天才寫出來，後來是發現原來UVa的毒瘤輸入N會=100，害我一直WA。注意：題目的n範圍應修正為$3 &lt; N \le 100$回歸正題，求次小生成樹的方法是：對於已經求好的MST，枚舉每一條未使用的邊，並且判斷加入此邊之後的最小升成樹大小(枚舉的邊必須使用到)。也代表假設加入的邊為a, b、長度v，則$原先MST大小-(a到b之間的最大邊長度)+v=此查詢的MST$，然後對每一次查詢的MST求min即可。 所以重點是要怎麼對每一次查詢求兩點之間的最大邊長，有以下幾種方法可求： 暴力：$O(N^2)$預處理，$O(1)$查詢 LCA倍增法：$O(NlogN)$預處理，$O(logN)$查詢 樹鏈剖分：$O(N)$預處理，$O(log^2N)$查詢 這裡我選擇用第二種方法，因為第一種在$n=10^5$的題目上就行不通，而樹鏈剖分常數大且查詢比較慢，實作上也比較難理解。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/************************************************************************* &gt; File Name: 10600 - ACM contest and Blackout.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Thu Sep 20 12:17:39 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;int n, m;struct l &#123; int a, b; int val; bool operator&lt; (const l &amp;b) const &#123; return val &lt; b.val; &#125; l() &#123;&#125; l(int a, int b, int v) : a(a), b(b), val(v) &#123;&#125;&#125;;vector&lt;l&gt; line;vector&lt;pair&lt;int,int&gt;&gt; mst[maxn];int parent[maxn], ans1, ans2;int logn;vector&lt;int&gt; dp[maxn], maxdp[maxn];int deep[maxn];int find(int i) &#123; if (i == parent[i]) return i; return parent[i] = find(parent[i]);&#125;void MST() &#123; for (int i = 0; i &lt;= n; i++) &#123; parent[i] = i; mst[i].clear(); &#125; int cnt = 0; for (auto &amp;i : line) &#123; int a = find(i.a); int b = find(i.b); if (a == b) continue; parent[b] = a; mst[i.a].emplace_back(make_pair(i.b, i.val)); mst[i.b].emplace_back(make_pair(i.a, i.val)); ans1 += i.val; i.val = 0; if (++cnt == n - 1) break; &#125; &#125;void dfs(int now, int parent, int len) &#123; dp[now].resize(logn); maxdp[now].resize(logn); dp[now][0] = parent; maxdp[now][0] = len; for (int i = 0; i + 1 &lt; logn; i++) &#123; dp[now][i + 1] = dp[dp[now][i]][i]; maxdp[now][i + 1] = max(maxdp[now][i], maxdp[dp[now][i]][i]); &#125; for (auto &amp;i : mst[now]) &#123; if (i.first == parent) continue; deep[i.first] = deep[now] + 1; dfs(i.first, now, i.second); &#125;&#125;int LCA(int a, int b) &#123; if (deep[a] &lt; deep[b]) swap(a, b); int mx = -1; for (int i = deep[a] - deep[b], k = 0; i; i &gt;&gt;= 1, k++) if (i &amp; 1) &#123; mx = max(mx, maxdp[a][k]); a = dp[a][k]; &#125; if (a == b) return mx; for (int i = logn - 1; i &gt;= 0; i--) &#123; if (dp[a][i] != dp[b][i]) &#123; mx = max(mx, max(maxdp[a][i], maxdp[b][i])); a = dp[a][i]; b = dp[b][i]; &#125; &#125; return max(max(mx, maxdp[a][0]), maxdp[b][0]);&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int c; cin &gt;&gt; c; while (c--) &#123; cin &gt;&gt; n &gt;&gt; m; line.resize(m); for (int i = 0; i &lt; m; i++) &#123; int a, b, v; cin &gt;&gt; a &gt;&gt; b &gt;&gt; v; a--; b--; line[i] = &#123;a, b, v&#125;; &#125; sort(line.begin(), line.end()); ans1 = 0; ans2 = 1 &lt;&lt; 30; MST(); logn = log2(n) + 1; dfs(0, 0, 0); for (auto &amp;i : line) &#123; if (!i.val) continue; ans2 = min(ans2, i.val - LCA(i.a, i.b)); &#125; cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans1 + ans2 &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Tree</tag>
        <tag>LCA</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 165. Stamps]]></title>
    <url>%2F2018%2F09%2F15%2FUVa-165-Stamps%2F</url>
    <content type="text"><![CDATA[Description每張信封上面最多可以貼上h張郵票，請設計k種面額，並求出能組成的連續面額最大值。例如當$h=3, k=2$，1和3元的面額最多可以連續從1組到7。 Input Format輸入包含多筆測資每組測資會給予$h$和$k$當$h=k=0$時結束程式 Output Format每組測試資料輸出一列，輸出k種面額，以及最大連續面額為多少。 Sample Input3 20 0 Sample Output1 3 -&gt; 7 UVa - 165 Solution首先，可以先確認一定會有面額為1的郵票，因為畢竟是要組成連續的數字。接著使用DFS求出第$2~k$的郵票面額。在我的程式裡面，use[i]表第$i$郵票的值；maxsum[i]陣列表示第i郵票及之前所有郵票可以組到的連續面額最大值。對於每一次遞迴，可確定當前第$i$個郵票枚舉的面額範圍必為use[i - 1] + 1 ~ maxsum[i - 1] + 1 優化筆記： 在求maxsum[]的時候，有一種做法是DFS暴力搜尋所有組合，這裡使用DP+Bitwise的方法優化。 在將use複製到ans時，用memcpy取代for，可以降低執行時間，優化結果如下圖。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/************************************************************************* &gt; File Name: 00165 - Stamps.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Fri Feb 16 16:53:08 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;int h, k, mx;int use[10], maxsum[10], ans[10];char check[75];int bit;void search(int index) &#123; if (index == k) &#123; if (maxsum[k - 1] &gt; mx) &#123; mx = maxsum[k - 1]; memcpy(ans, use, sizeof(ans)); &#125; return; &#125; for (int i = use[index - 1] + 1; i &lt;= maxsum[index - 1] + 1; i++) &#123; memset(check, 0, sizeof(check)); check[0] = 1; use[index] = i; for (int j = 0; j &lt;= index; j++) for (int k = use[j]; k &lt; 75; k++) check[k] |= check[k - use[j]] &lt;&lt; 1; int j = 0; while (check[++j] &amp; bit); maxsum[index] = j - 1; search(index + 1); &#125;&#125;int main() &#123; while (scanf("%d%d", &amp;h, &amp;k) &amp;&amp; h + k) &#123; memset(use, 0, sizeof(use)); ans[0] = use[0] = 1; maxsum[0] = h; mx = 0; bit = 1; for (int i = 0; i &lt; h; i++) bit |= bit &lt;&lt; 1; search(1); for (int i = 0; i &lt; k; i++) printf("%3d", ans[i]); printf(" -&gt;%3d\n", mx); &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dynamic Programming</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 10917. Walk Through the Forest]]></title>
    <url>%2F2018%2F09%2F09%2FUVa-10917-Walk-Through-the-Forest%2F</url>
    <content type="text"><![CDATA[DescriptionJimmy的辦公室在森林的一邊，而他的家在森林的另一邊。Jimmy想要每天都走不同的路徑回家。但是他也不想要回家太晚，所以他總是選擇一條可以朝他家「前進」的路徑來走。所謂「前進」指的是他會選擇從A點走到B點如果B點存在一條到他家的路徑長度比A點到他家任一路徑的長度都來的短的話。請你算出Jimmy共有多少種不同的路徑可以走。 Input Format輸入包含多筆測資第一列包含兩個整數N$(1 &lt; N \le 1000)$和M，N代表有多少點(編號從1到N，請注意：編號1的點為Jimmy的辦公室，編號2的點為Jimmy的家)，M代表共有多少個連接2個點的邊。接下來的M列每列有3個整數 a, b, d。a,b為點的編號，d 為連接 a,b 的路徑長（在這裡 a,b 不會相同，$1 \le d \le 1000000$）。路徑是雙向的，且任2點之間僅有一條路徑連接。 Output Format每組測試資料輸出一列，Jimmy共有多少種不同的路徑可以走。 Sample Input5 61 3 21 4 23 4 31 5 124 2 345 2 247 81 3 11 4 13 7 17 4 17 5 16 7 15 2 16 2 15 7 Sample Output24 UVa - 10917翻譯來源：Luckycat Solution這題還滿有趣的，因為朝家「前進」，所以需要重新構圖。由於每步都會朝他家「前進」，所以可以先想到對於點2去做單源最短路徑(Dijkstra)。然後再重新構圖，且這邊要注意是有向邊。注意：以下Code點的編號是從0到N-1 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/************************************************************************* &gt; File Name: 10917 - A Walk Through the Forest.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Tue Sep 4 12:04:50 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; link[1001];vector&lt;int&gt; rebuild[1001];const int inf = 1 &lt;&lt; 30;int distant[1001];int dp[1001];bool visit[1001];int n, m;struct node &#123; int dis, index; bool operator&lt; (const node &amp;b) const &#123; return dis &gt; b.dis; &#125; node() &#123;&#125; node(int d, int i) : dis(d), index(i) &#123;&#125;&#125;;int dfs(int now) &#123; if (now == 1) return 1; if (dp[now] == -1) &#123; dp[now] = 0; for (auto i : rebuild[now]) dp[now] += dfs(i); &#125; return dp[now];&#125;void dijkstra() &#123; priority_queue&lt;node&gt; pq; pq.push(node(0, 1)); int cur; distant[1] = 0; while (!pq.empty()) &#123; cur = pq.top().index; pq.pop(); if (visit[cur]) continue; visit[cur] = 1; for (auto i : link[cur]) &#123; int next = i.first; int dis = i.second; if (distant[next] &gt; distant[cur] + dis) &#123; distant[next] = distant[cur] + dis; pq.push(node(distant[next], next)); &#125; &#125; &#125;&#125;void build() &#123; memset(dp, -1, sizeof(dp)); int next, dis; for (int i = 0; i &lt; n; i++) &#123; rebuild[i].clear(); for (auto j : link[i]) if (distant[i] &gt; distant[j.first]) rebuild[i].emplace_back(j.first); &#125;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int a, b, c; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123; memset(link, 0, sizeof(link)); memset(visit, 0, sizeof(visit)); for (int i = 0;i &lt; n; i++) distant[i] = inf; while (m--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; link[--a].push_back(&#123;--b, c&#125;); link[b].push_back(&#123;a, c&#125;); &#125; dijkstra(); build(); cout &lt;&lt; dfs(0) &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dynamic Programming</tag>
        <tag>DFS</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 12538. Version Controlled IDE]]></title>
    <url>%2F2018%2F08%2F26%2FUVa-12538-Version-Controlled-IDE%2F</url>
    <content type="text"><![CDATA[Description題目有三種操作：1 p s: 在當前字串位置p後插入s字串。2 p c: 將當前字串位置p後面連續c個字符移除。3 v p c: 在版本號v的字串中，在位置p之後印出c個字元。 由於怕離線處理，因此輸入的數值會進行加密：每個數字會增加數值d，其d為當前打印字符c的個數。 Sample Input61 0 abcdefgh2 4 33 1 2 53 3 3 41 4 xy3 5 4 6 Sample Outputbcdefbcgbxyc UVa - 12538 Solution這題需要利用可持久化Treap來解。持久化Treap與一般的Treap在寫法上來看其實差異點只有兩點： 因為複製點的時候會連Priority值一起複製，導致之後Treap會接近鏈狀，所以需要將Treap改成「隨機二叉樹」，在merge的時候，將Priority值比較的部分改成亂數（第51行）。 持久化的概念在於Copy-on-write，所以在split或是merge的時候均需要複製（new node()）一遍。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/************************************************************************* &gt; File Name: 12538 - Version Controlled IDE.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Sun Aug 26 00:22:34 2018 *************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;int n, cnt, cmd, version;int a, b, c;string s;struct node &#123; int s; char c; node *l, *r; node(char _c):c(_c) &#123; s = 1; l = r = nullptr; &#125; inline void up() &#123; s = 1 + (l ? l-&gt;s : 0) + (r ? r-&gt;s : 0); &#125; void print() &#123; if (l) l-&gt;print(); cout &lt;&lt; c; if (c == 'c') cnt++; if (r) r-&gt;print(); &#125;&#125;*root[50010];inline int size(node *o) &#123; return o ? o-&gt;s : 0;&#125;void build(node *&amp;o, int l, int r, string &amp;s) &#123; if (l &gt; r) return; int m = (l + r) &gt;&gt; 1; o = new node(s[m]); build(o-&gt;l, l, m - 1, s); build(o-&gt;r, m + 1, r, s); o-&gt;up();&#125;node* merge(node *a, node *b) &#123; if (!a || !b) return a ? (new node(*a)) : (new node(*b)); if (rand() % (a-&gt;s + b-&gt;s) &lt; a-&gt;s) &#123; a = new node(*a); a-&gt;r = merge(a-&gt;r, b); a-&gt;up(); return a; &#125; b = new node(*b); b-&gt;l = merge(a, b-&gt;l); b-&gt;up(); return b;&#125;void split(node *o, node *&amp;a, node *&amp;b, int k) &#123; if (!o) a = b = nullptr; else if (k == 0) &#123; a = nullptr; b = new node(*o); &#125;else &#123; if (k &gt;= size(o-&gt;l) + 1) &#123; a = new node(*o); split(o-&gt;r, a-&gt;r, b, k - size(o-&gt;l) - 1); a-&gt;up(); &#125;else &#123; b = new node(*o); split(o-&gt;l, a, b-&gt;l, k); b-&gt;up(); &#125; &#125;&#125;void insert(int x, string &amp;s) &#123; node *a, *b, *c; split(root[version], a, c, x); build(b, 0, s.length() - 1, s); root[++version] = merge(a, merge(b, c)); return;&#125;void erase(int x, int k) &#123; node *a, *b, *b2, *c; split(root[version], a, b, x - 1); split(b, b2, c, k); root[++version] = merge(a, c);&#125;void print(int v, int s, int e) &#123; node *a, *b, *b2, *c; split(root[v], a, b, s - 1); split(b, b2, c, e); b2-&gt;print(); //root[v] = merge(a, merge(b2, c));&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; cmd; if (cmd == 1) &#123; cin &gt;&gt; a &gt;&gt; s; insert(a - cnt, s); &#125;else if (cmd == 2) &#123; cin &gt;&gt; a &gt;&gt; b; erase(a - cnt, b - cnt); &#125;else &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; print(a - cnt, b - cnt, c - cnt); cout &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>Treap</tag>
        <tag>Tree</tag>
        <tag>Persistence</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Fibonacci Matrix]]></title>
    <url>%2F2018%2F08%2F23%2FTemplate-Fibonacci-Matrix%2F</url>
    <content type="text"><![CDATA[$2 \times 2$矩陣表示費氏數列的方法如下 $ \begin{bmatrix} x_2 &amp; x_1 \\ 1 &amp; 0 \\ \end{bmatrix} ^ n = \begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n-1} \\ \end{bmatrix} $ 搭配快速冪的算法可以將$O(N)$的複雜度降低到$O(log N)$。 程式使用方法：calc(n, a1, a2, x1, x2)表第一項為a1，第二項為a2；n代表要求的第n項。且$a_n = x_1 \times a_{n-2} + x_2 \times a_{n-1}$。 1234567891011121314151617181920212223242526272829303132struct Matrix&#123; int c[2][2]; Matrix operator*(const Matrix &amp;rhs) const &#123; Matrix re; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) re.c[i][j] = 0; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) re.c[i][j] += c[i][k] * rhs.c[k][j]; return re; &#125;&#125;;Matrix Pow(int j, int x1, int x2) &#123; Matrix tra; tra.c[0][0] = x2; tra.c[0][1] = x1; tra.c[1][0] = 1; tra.c[1][1] = 0; Matrix re; re.c[0][0] = 1; re.c[0][1] = 0; re.c[1][0] = 0; re.c[1][1] = 1; for(; j; j &gt;&gt;= 1)&#123; if (j &amp; 1) re = re * tra; tra = tra * tra; &#125; return re;&#125;long long int calc(int n, int a1, int a2, int x1, int x2) &#123; Matrix a = Pow(n - 1, x1, x2); return a.c[1][0] * a2 + a.c[1][1] * a1;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Matrix</tag>
        <tag>Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 11456. Trainsorting]]></title>
    <url>%2F2018%2F08%2F21%2FUVa-11456-Trainsorting%2F</url>
    <content type="text"><![CDATA[DescriptionErin是一個開火車工程師。他喜歡把車廂按照其重量來安排，重的車廂排在前端。不幸的是，把車廂排序並不是一件容易的事。你只能將一節車廂加在一列火車的前端或後端。各個車廂來到火車站的順序及其重量是已經知道的。當每節車廂來到的時候，Erin可以把它加到火車的兩端，或者不加進去。最後，火車的總車廂數是越長越好，不過要記得車廂得按照重量大小排列。給你按照出現順序各車廂的重量，Erin最長可安排車廂的長度是多少？ Input Format輸入的第一列有一個整數表示測試資料的組數。每組資料的第一列會有1個整數$n$ ,$(0 \le n \le 2000)$，代表車廂的數目。接下來$n$列整數，每列有一個大於等於0的整數，代表各車廂的重量。請注意：所有車廂的重量都不一樣。請參考 Sample Input。 Output Format對每組測試資料，Erin最長可安排車廂的長度是多少。 Sample Input13123 Sample Output3 UVa - 11456翻譯來源：Luckycat Solution因為有選取或不選取，可以考慮到使用DP的方法解。令$up[i]\ down[i]$代表重量 大於/小於 第$i$車廂的最大車廂數。接著跑迴圈每次取$max(ans, up[i] + down[i]-1)$就可以得到答案了。 Code1234567891011121314151617181920212223242526272829303132333435/************************************************************************* &gt; File Name: 11456 - Trainsorting.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Sat May 19 14:10:47 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;int up[2002], down[2002];int input[2003];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int c, n; cin &gt;&gt; c; while(c--) &#123; cin &gt;&gt; n; for (int i = n; i; i--) cin &gt;&gt; input[i]; int ans = 0; for (int i = 1; i &lt;= n; i++) up[i] = down[i] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (input[j] &lt; input[i]) up[i] = max(up[i], up[j] + 1); else down[i] = max(down[i], down[j] + 1); &#125; ans = max(ans, up[i] + down[i] - 1); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Persistent Segment Tree]]></title>
    <url>%2F2018%2F08%2F20%2FTemplate-Persistent-Segment-Tree%2F</url>
    <content type="text"><![CDATA[可持久化線段樹適用於查詢不同版本的線段樹，其運作方式非常簡單，就是將要更改的點先複製一遍，未更改的點則不動。而且每新增一個節點，就建立一個新的root，所以我們就可以透過不同的root來讀取不同版本的值。 如下圖：以下為區間和的持久化線段樹，同時也為Zero Judge a331的AC Code。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int sum; node *l, *r; node()&#123;l = r = nullptr;&#125; node(int n) : sum(n)&#123;l = r = nullptr;&#125; void up() &#123; sum = 0; if (l) sum += l-&gt;sum; if (r) sum += r-&gt;sum; &#125;&#125;*tree[100010];int in[100010];int n, m;node* build(int l, int r) &#123; node *o = new node(0); if (l == r) return o; int m = (l + r) &gt;&gt; 1; o-&gt;l = build(l, m); o-&gt;r = build(m + 1, r); return o;&#125;node* insert(node *o, int l, int r, int x, int num) &#123; if (l &gt; x || x &gt; r) return o; o = new node(*o); if (l == r &amp;&amp; r == x) &#123; o-&gt;sum = num; return o; &#125; int m = (l + r) &gt;&gt; 1; o-&gt;l = insert(o-&gt;l, l, m, x, num); o-&gt;r = insert(o-&gt;r, m + 1, r, x, num); o-&gt;up(); return o;&#125;int find(node *f, node *b, int l, int r, int k) &#123; if (l == r) return l; int m = (l + r) &gt;&gt; 1; int nxt = b-&gt;l-&gt;sum - f-&gt;l-&gt;sum; if (k &lt;= nxt) return find(f-&gt;l, b-&gt;l, l, m, k); return find(f-&gt;r, b-&gt;r, m + 1, r, k - nxt);&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); while (cin &gt;&gt; n &gt;&gt; m) &#123; vector&lt;int&gt; v; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; in[i]; v.emplace_back(in[i]); &#125; sort(v.begin(), v.end()); v.resize(unique(v.begin(), v.end()) - v.begin()); tree[0] = build(0, v.size()); for (int i = 1; i &lt;= n; i++) tree[i] = insert(tree[i - 1], 0, v.size(), lower_bound(v.begin(), v.end(), in[i]) - v.begin(), 1); while (m--) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; v[find(tree[a - 1], tree[b], 0, v.size(), c)] &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Segment Tree</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 1479. Graph and Queries]]></title>
    <url>%2F2018%2F08%2F18%2FUVa-1479-Graph-and-Queries%2F</url>
    <content type="text"><![CDATA[Description給定一張無向圖，有三種操作： D x ：刪除第x條邊 Q x y ：查詢x所在集合裡面第y大的數字，若查詢失敗，則此次查詢的結果為0 C x y ：將第x點的值改成y 最後輸出所有查詢的平均值。 詳細內容請參照UVa 1479 Sample Input3 31020301 22 31 3D 3Q 1 2Q 2 1D 2Q 3 2C 1 50Q 1 1E3 31020201 22 31 3Q 1 1Q 1 2Q 1 3E0 0 Sample OutputCase 1: 25.000000Case 2: 16.666667 UVa - 1479 Solution經典Treap題目。在這題目中，比較棘手的問題是「如何刪除邊」？既然刪除邊非常困難，那我們可以換個角度思考：將操作順序前後顛倒，刪除邊的操作改成新增邊。所以現在就解決了最重要的問題。 但是要怎麼merge兩個獨立的Treap？不能使用原本的merge()函數是因為我們不能保證這兩棵獨立的treap之間key值的大小關係。所以這裡需要用到啟發式合併：將小的樹堆所有數字都insert到大的裡面，並且delete掉以釋放空間。啟發式合併的時間複雜度乍看之下很大，但是網路上已經有人證明這種方法複雜度只有到$O(n log_2 n)$，是一個非常好的方法。 然後最後一點，在Disjoint set合併的時候，要特別注意是parent[pb] = pa;($|pa| \ge |pb|$)。另外，在查詢的時候，需注意回傳的指標是否為null，否則會導致RE。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/************************************************************************* &gt; File Name: new.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Fri Aug 17 09:26:25 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;#define F first#define S secondusing namespace std;int n, m;int rand() &#123; static int x = 123456789; return x += (x &lt;&lt; 2) + 1;&#125;struct node &#123; node *l, *r; int key, s, pri; node()&#123;l = r = nullptr;&#125; node(int k): key(k)&#123;l = r = nullptr; s = 1; pri = rand();&#125;; void up() &#123; s = 1; if (l) s += l-&gt;s; if (r) s += r-&gt;s; &#125;&#125;;int size(node *a) &#123; return a ? a-&gt;s : 0;&#125;node* root[20010];node* merge(node *a, node *b) &#123; if (!a || !b) return a ? a : b; if (a-&gt;pri &lt; b-&gt;pri) &#123; a-&gt;r = merge(a-&gt;r, b); a-&gt;up(); return a; &#125; b-&gt;l = merge(a, b-&gt;l); b-&gt;up(); return b;&#125;void split(node *o, node *&amp;a, node *&amp;b, int k) &#123; if (!o) a = b = nullptr; else &#123; if (o-&gt;key &lt; k) &#123; a = o; split(o-&gt;r, a-&gt;r, b, k); &#125;else &#123; b = o; split(o-&gt;l, a, b-&gt;l, k); &#125; o-&gt;up(); &#125;&#125;void insert(node *&amp;root, int k) &#123; node *a, *b; split(root, a, b, k); root = merge(a, merge(new node(k), b));&#125;bool erase(node *&amp;o, int k) &#123; if (!o) return 0; if (o-&gt;key == k) &#123; node *tmp = o; o = merge(o-&gt;l, o-&gt;r); delete tmp; return 1; &#125; node *&amp;next = (o-&gt;key &gt; k ? o-&gt;l : o-&gt;r); if (erase(next, k)) return o-&gt;up(), 1; return 0;&#125;node* kth(node *o, int k) &#123; if (!o || k &lt;= 0 || k &gt; o-&gt;s) return nullptr; if (size(o-&gt;r) + 1 == k) return o; if (size(o-&gt;r) &gt;= k) return kth(o-&gt;r, k); return kth(o-&gt;l, k - size(o-&gt;r) - 1);&#125;void merge_tree(node *&amp;o, node *&amp;target) &#123; if (!o) return; if (o-&gt;l) merge_tree(o-&gt;l, target); if (o-&gt;r) merge_tree(o-&gt;r, target); insert(target, o-&gt;key); delete o; o = nullptr;&#125;int parent[20010];int p(int x) &#123; return x == parent[x] ? x : parent[x] = p(parent[x]);&#125;void merge_point(int a, int b) &#123; a = p(a); b = p(b); if (a == b) return; if (root[a]-&gt;s &lt; root[b]-&gt;s) swap(a, b); parent[b] = a; merge_tree(root[b], root[a]);&#125;struct CMD &#123; char c; int a, b;&#125;cmd[1 &lt;&lt; 20];int w[20010];bool connect[60010];pair&lt;int, int&gt; joint[60010];int main() &#123; int a, b, q, cas = 1; char c; double sum; int divid; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; memset(connect, 0, sizeof(connect)); for (int i = 1; i &lt;= m; i++) cin &gt;&gt; joint[i].F &gt;&gt; joint[i].S; for (q = 0; ; ) &#123; cin &gt;&gt; c; if (c == 'E') break; cin &gt;&gt; a; if (c == 'D') connect[a] = 1; else &#123; cin &gt;&gt; b; if (c == 'C') swap(b, w[a]); &#125; cmd[q++] = &#123;c, a, b&#125;; &#125; for (int i = 1; i &lt;= n; i++) &#123; root[i] = nullptr; insert(root[i], w[i]); parent[i] = i; &#125; for (int i = 1; i &lt;= m; i++) if (!connect[i]) merge_point(joint[i].F, joint[i].S); divid = sum = 0; while (q--) &#123; a = cmd[q].a; b = cmd[q].b; c = cmd[q].c; if (c == 'D') merge_point(joint[a].F, joint[a].S); else if (c == 'Q') &#123; divid++; int pa = p(a); node *tmp = kth(root[pa], b); sum += tmp ? tmp-&gt;key : 0; &#125;else &#123; int pa = p(a); erase(root[pa], w[a]); insert(root[pa], b); w[a] = b; &#125; &#125; cout &lt;&lt; "Case " &lt;&lt; cas++ &lt;&lt; ": " &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; sum / divid &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint set</tag>
        <tag>Treap</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. KMP]]></title>
    <url>%2F2018%2F08%2F16%2FTemplate-KMP%2F</url>
    <content type="text"><![CDATA[KMP字串比對，回傳第一組子字串的位置。若失敗則回傳-1。 12345678910111213141516171819202122int kmp(const string &amp;T, const string &amp;P) &#123; if (P.empty()) return 0; vector&lt;int&gt; fail(P.size(), 0); for (unsigned i = 1, k = 0; i &lt; P.size(); i++) &#123; while (k &amp;&amp; P[k] != P[i]) k = fail[k - 1]; if (P[k] == P[i]) k++; fail[i] = k; &#125; for (unsigned i = 0, k = 0; i &lt; T.size(); i++) &#123; while (k &amp;&amp; P[k] != T[i]) k = fail[k - 1]; if (P[k] == T[i]) k++; if (k == P.size()) return i - k + 1; // success &#125; return -1; // fail&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Heavy-light Decomposition]]></title>
    <url>%2F2018%2F08%2F15%2FTemplate-Heavy-light-Decomposition%2F</url>
    <content type="text"><![CDATA[第一次DFS，son()：先紀錄所有點的子節點（含）數目、深度等資訊。第二次DFS，build()：依據上次DFS的結果，優先選擇子節點最多的點構成重鏈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define maxn 100001struct node &#123; int size, max_son, parent, dep;&#125;n[maxn];int link_top[maxn], link[maxn];int global_time = 0;vector&lt;int&gt; tree[maxn];void son(int now, int p) &#123; node &amp;cur = n[now]; cur.size = 1; cur.max_son = -1; for (int i : tree[now]) &#123; if (i == p) continue; n[i].parent = now; n[i].dep = cur.dep + 1; son(i, now); if (cur.max_son == -1 || n[i].size &gt; n[cur.max_son].size) cur.max_son = i; cur.size += n[i].size; &#125;&#125;void build(int now, int top) &#123; link[now] = ++global_time; link_top[now] = top; if (n[now].size == 1) return; build(n[now].max_son, top); for (int i : tree[now]) &#123; if (i == n[now].max_son || i == n[now].parent) continue; build(i, i); &#125;&#125;int lca(int a, int b) &#123; int ta = link_top[a]; int tb = link_top[b]; while (ta != tb) &#123; if (n[ta].dep &lt; n[tb].dep) &#123; swap(ta, tb); swap(a, b); &#125; ta = link_top[a = n[ta].parent]; &#125; return n[a].dep &lt; n[b].dep ? a : b;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>LCA</tag>
        <tag>Heavy-light Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. LCA Doubling Search]]></title>
    <url>%2F2018%2F08%2F15%2FTemplate-LCA-Doubling-Search%2F</url>
    <content type="text"><![CDATA[使用倍增法的做法來計算LCA。先製作dp表，$dp[i][j]$代表$i$的第$2^j$祖先是誰，若不存在則為-1。在查詢時，先將點$a$和$b$調整到相同高度，再一起慢慢往上移動尋找LCA。時間複雜度：$O(N log N)$ 123456789101112131415161718192021222324252627282930313233343536373839#define maxn 1000int n, logn; //logn = log2(n) + 1vector&lt;int&gt; tree[maxn];vector&lt;int&gt; dp[maxn];int deep[maxn];void init() &#123; logn = log2(n) + 1; dfs(0, 0);&#125;void dfs(int now, int parent) &#123; dp[now].resize(logn); for (int i = 1; i &lt; logn; i++) dp[now][i] = -1; dp[now][0] = parent; for (int i = 0; i + 1 &lt; logn; i++) dp[now][i + 1] = dp[dp[now][i]][i]; for (int i : tree[now]) &#123; if (i == parent) continue; deep[i] = deep[now] + 1; dfs(i, now); &#125;&#125;int LCA(int a, int b) &#123; if (deep[a] &lt; deep[b]) swap(a, b); for (int i = deep[a] - deep[b], k = 0; i; i &gt;&gt;= 1, k++) if (i &amp; 1) a = dp[a][k]; if (a == b) return a; for (int i = logn; i &gt;= 0; i--) &#123; if (dp[a][i] != dp[b][i]) &#123; a = dp[a][i]; b = dp[b][i]; &#125; &#125; return dp[a][0];&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Strongly Connect Component]]></title>
    <url>%2F2018%2F08%2F15%2FTemplate-Strongly-Connect-Component%2F</url>
    <content type="text"><![CDATA[使用point來記錄點的路徑，結果存在result。 12345678910111213141516171819202122232425262728293031#define maxn 1000int id = 1;int dfs_time = 0;int visit[maxn] = &#123;0&#125;;int low[maxn];bool in_stack[maxn] = &#123;0&#125;;int result[maxn]; //結果存在這裏 //result[x]代表x點所在的編號stack&lt;int&gt; sta;vector&lt;int&gt; point[maxn];void scc(int now) &#123; visit[now] = low[now] = ++dfs_time; sta.push(now); in_stack[now] = 1; for (int i : point[now]) &#123; if (!visit[i]) &#123; scc(i); if (in_stack[i]) low[now] = min(low[now], low[i]); &#125; if (visit[now] == low[now]) &#123; int tmp; do &#123; in_stack[tmp = sta.top()] = 0; sta.pop(); result[tmp] = id; &#125;while (tmp != now); id++; &#125;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Tarjan Algorithm</tag>
        <tag>SCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Treap]]></title>
    <url>%2F2018%2F08%2F14%2FTemplate-Treap%2F</url>
    <content type="text"><![CDATA[Treap = Heap + Tree。 Usage 宣告：treap&lt;型別&gt; a, b; 插入：a.insert(100); 刪除：a.erase(100); 查詢第k大（回傳node指標，取-&gt;key即可得到該數字）：a.kth(1); 查詢某數為第幾大（0為第一個）：a.rank(100); Template123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114int rand() &#123; static int x = 123456789; return x += (x &lt;&lt; 2) + 1;&#125;template &lt;typename T&gt;struct treap &#123; struct node &#123; node *l, *r; T key; int pri, size; node(T k):key(k) &#123; l = r = nullptr; pri = rand(); size = 1; &#125; void up() &#123; size = 1; if (l) size += l-&gt;size; if (r) size += r-&gt;size; &#125; &#125;; node *root = nullptr; int size(node *a) &#123; if (!a) return 0; return a-&gt;size; &#125; node* merge(node *a, node *b) &#123; if (!a || !b) return a ? a : b; if (a-&gt;pri &lt; b-&gt;pri) &#123; a-&gt;r = merge(a-&gt;r, b); a-&gt;up(); return a; &#125; b-&gt;l = merge(a, b-&gt;l); b-&gt;up(); return b; &#125; void split(node *R, node *&amp;a, node *&amp;b, T k) &#123; if (!R) a = b = nullptr; else if (R-&gt;key &lt; k) &#123; a = R; split(R-&gt;r, a-&gt;r, b, k); R-&gt;up(); &#125;else &#123; b = R; split(R-&gt;l, a, b-&gt;l, k); R-&gt;up(); &#125; &#125; void insert(node *&amp;Root, T k) &#123; node *a, *b; split(Root, a, b, k); Root = merge(a, merge(new node(k), b)); &#125; bool erase(node *&amp;R, T k) &#123; if (!R) return 0; if (R-&gt;key == k) &#123; node *tmp = R; R = merge(R-&gt;l, R-&gt;r); delete tmp; return 1; &#125; node *&amp;nxt = R-&gt;key &gt; k ? R-&gt;l : R-&gt;r; if (erase(nxt, k)) &#123; R-&gt;up(); return 1; &#125; return 0; &#125; void split2(node *R, node *&amp;a, node *&amp;b, int k) &#123; if (!R) a = b = nullptr; else &#123; if (k &gt;= size(R-&gt;l) + 1) &#123; a = R; split2(R-&gt;r, a-&gt;r, b, k - size(R-&gt;l) - 1); &#125;else &#123; b = R; split2(R-&gt;l, a, b-&gt;l, k); &#125; R-&gt;up(); &#125; &#125; //Simple way to use: void insert(T k) &#123; insert(root, k); &#125; bool erase(T k) &#123; return erase(root, k); &#125; int rank(T k) &#123; node *a, *b; split(root, a, b, k); int re = size(a); root = merge(a, b); return re; &#125; node* kth(int k) &#123; node *a, *b, *c; a = b = c = nullptr; split2(root, a, c, k); split2(a, a, b, k - 1); root = merge(merge(a, b), c); return b; &#125;&#125;; Demo123456treap&lt;int&gt; t;t.insert(1);t.insert(2);t.insert(100);cout &lt;&lt; t.kth(3)-&gt;key &lt;&lt; '\n';cout &lt;&lt; t.rank(1) &lt;&lt; '\n';]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Treap</tag>
        <tag>Tree</tag>
        <tag>Persistence</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 10032. Tug of War]]></title>
    <url>%2F2018%2F08%2F11%2FUVa-10032-Tug-of-War%2F</url>
    <content type="text"><![CDATA[DescriptionN個人參加拔河比賽，每個人有其重量w[i]，欲使二隊的人數最多只差一，雙方的重量和越接近越好。請問二隊的重量和分別是多少？ Input Format第一列有一個整數，代表以下有幾組測試資料。每筆測試資料的第1列有一個整數 n$(n\le100)$，代表共有n個人參加拔河。接下來的n列，代表這n個人的體重，體重均界於1到450之間。測試資料間有空一列。請參考Sample Input。 Output Format每一筆測試資料請輸出一列，包含2個整數，代表2隊的總體重。如果這2個數不相同，小的在前面。測試資料間有空一列。請參考Sample Output。 Sample Input1310090200 Sample Output190 200 UVa - 10032翻譯來源：Luckycat Solution這題可以用一般的DP解，令bool dp[i][k]代表 是否可以在選擇$k$人時，其重量總和為$i$ ，如果是這樣解的話，時間複雜度會到$O(n^2 \times \text{sum_of_weight})$，所以以最大測資來看需要計算$100^2 \times 17500 = 1.75 \times 10^8$次，很明顯地會TLE，所以這時候就要用位元運算來簡化。首先我們令long long int dp[i]代表 當重量為$i$時，有哪些人數可以達成 。假設dp[5] = 0b001010; (0b是使用二進位的表示方法)，代表可以選擇1和3人使其重量和為5。詳細解法請看Code。時間複雜度$O(n^2 + \text{sum_of_weight})$ Code123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************************* &gt; File Name: 10032 - Tug of War.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Wed Feb 14 19:23:28 2018*************************************************************************/#include &lt;iostream&gt;using namespace std;long long dp[22600];int input[110];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int c, n, sum, Sh, Nh; cin &gt;&gt; c; while (c--) &#123; cin &gt;&gt; n; sum = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; input[i]; sum += input[i]; &#125; Sh = sum &gt;&gt; 1; Nh = (n + 1) &gt;&gt; 1; for (int i = 1; i &lt;= Sh; i++) dp[i] = 0; dp[0] = 1; for (int i = 0; i &lt; n; i++) for (int j = Sh; j &gt;= input[i]; j--) dp[j] |= dp[j - input[i]] &lt;&lt; 1LL; for (int i = Sh; i &gt;= 0; i--) if (dp[i] &gt;&gt; Nh &amp; 1 || ((n &amp; 1) &amp;&amp; (dp[i] &gt;&gt; (Nh - 1) &amp; 1))) &#123; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; sum - i &lt;&lt; '\n'; break; &#125; if (c) cout &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dynamic Programming</tag>
        <tag>Bitwise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 10949. Kids in a Grid]]></title>
    <url>%2F2018%2F08%2F09%2FUVa-10949-Kids-in-a-Grid%2F</url>
    <content type="text"><![CDATA[Description兩個小孩在H*W的格子上走動，每個方格都含有一個字元(ASC碼在33和127間)，這兩個小孩每一步可以走東、西、南、北的任一方向(北是向上，南是向下，東是向右，西是向左)，第一個小孩走了N步，第二個小孩走了M步。$(0 \le N \le M \le 20000)$如果我們把他們走過的字母寫成字串，我們可以得到兩串字串$S_A$和$S_B$。你的任務是消掉最少的字元，讓$S_A$和$S_B$變成相等的字串。 Input Format第一行有一個整數t $(1 \le t \le 15)$，代表有幾組測資，每組測資包含數列。第一列有兩個整數 H 和 W$(1 \le H, W \le 20)$。以下的 H 列為格子上的字元。下一列有3個整數 N、$X_0$、$Y_0$$(1 \le X_0 \le H, 1 \le Y_0 \le W)$，最左上角那格代表(1,1)。第一個小孩從$(X_0,Y_0)$開始走N步，下一列有一串長度為N的字串，N(北)、S(南)、E(東)、W(西)表示他走的方向。第二個小孩走的方法也是類似的。你可以假設小孩走的序列是正確的，也就是說絕不會走出格子外。請參考Sample Input。 Output Format對每一組測試資料輸出這是第幾組測資和兩個正整數$X_A$和$X_B$，分別是$S_A$和$S_B$需要消掉的最少字元數。 Sample Input23 4ABCDDEFGABCD4 1 1EEES3 3 1NES3 4ABCDDEFGABCD4 1 1EEES3 3 1NES Sample OutputCase 1: 3 2Case 2: 3 2 UVa - 10949翻譯來源：Luckycat Solution這題就是先產生路徑再套LCS，不過需要注意的是 $O(N^2)$ 方法會TLE，需要改成 $O(N log N)$模板庫有較詳細的解說 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/************************************************************************* &gt; File Name: 10949 - Kids in a Grid.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Thu Aug 9 19:33:40 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;string road[20];void input(string &amp;t) &#123; int len, x, y; char c; cin &gt;&gt; len &gt;&gt; x &gt;&gt; y; x--; y--; t += road[x][y]; while (len--) &#123; cin &gt;&gt; c; switch (c) &#123; case 'N': x--; break; case 'S': x++; break; case 'W': y--; break; case 'E': y++; &#125; t += road[x][y]; &#125;&#125;int sol(string a, string b) &#123; //a &gt; b vector&lt;int&gt; tmp[128]; for (int i = 0; i &lt; a.length(); i++) tmp[a[i]].push_back(i); vector&lt;int&gt; lis; lis.push_back(-1); for (int i = 0; i &lt; b.length(); i++) &#123; int now = b[i]; for (int i = tmp[now].size() - 1; i &gt;= 0; i--) &#123; if (tmp[now][i] &gt; lis.back()) lis.push_back(tmp[now][i]); else *lower_bound(lis.begin(), lis.end(), tmp[now][i]) = tmp[now][i]; &#125; &#125; return lis.size() - 1;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int c; cin &gt;&gt; c; for (int i = 0; i &lt; c;) &#123; string a, b; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; road[i]; input(a); input(b); int ans = (a.length() &gt; b.length() ? sol(a, b) : sol(b, a)); cout &lt;&lt; "Case " &lt;&lt; ++i &lt;&lt; ": " &lt;&lt; a.length() - ans &lt;&lt; ' ' &lt;&lt; b.length() - ans &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>LCS</tag>
        <tag>Greedy</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Longest Common Subsequence]]></title>
    <url>%2F2018%2F08%2F09%2FTemplate-Longest-Common-Subsequence%2F</url>
    <content type="text"><![CDATA[Dynamic Programming時間複雜度：$O(N^2)$ 123456789101112#define maxn 1000int lcs(string a, string b) &#123; int dp[maxn + 1][maxn + 1]; dp[0][0] = dp[1][0] = dp[0][1] = 0; for (int i = 1; i &lt;= a.length(); i++) for (int j = 1; j &lt;= b.length(); j++) if (a[i - 1] == b[j - 1]) lis[i][j] = lis[i - 1][j - 1] + 1; else lis[i][j] = max(lis[i - 1][j], lis[i][j - 1]); return lis[a.length()][b.length()];&#125; Greedy首先用 $O(N)$ 的方式先將LCS問題轉成LIS，再用Greedy方式算出LCS。參考資料：演算法筆記。時間複雜度：$O(N log N)$ 123456789101112131415161718int lcs(string a, string b) &#123; if (a.length() &lt; b.length()) swap(a, b); vector&lt;int&gt; tmp[256]; for (int i = 0; i &lt; a.length(); i++) tmp[a[i]].push_back(i); vector&lt;int&gt; lis; lis.push_back(-1); for (int i = 0; i &lt; b.length(); i++) &#123; int now = b[i]; for (int i = tmp[now].size() - 1; i &gt;= 0; i--) if (tmp[now][i] &gt; lis.back()) lis.push_back(tmp[now][i]); else *lower_bound(lis.begin(), lis.end(), tmp[now][i]) = tmp[now][i]; &#125; return lis.size() - 1;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>LCS</tag>
        <tag>Greedy</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 315. Network]]></title>
    <url>%2F2018%2F08%2F09%2FUVa-315-Network%2F</url>
    <content type="text"><![CDATA[Description一家電話公司在許多地方建有機房，這些機房以1到N來編號，沒有2個地方有相同的號碼。電纜線是雙向的，並且只有在機房中的交換機才可互相連接（每個機房只有一部交換機）。電話訊號可以從一個機房傳到另一個機房，但是這些機房並不一定要直接相連，它們之間的通訊可能是透過好幾個交換機。偶爾當有停電的情況發生時，當地的機房也會因停電而無法運作。這個時候不僅這個機房的通訊中斷，可能也有其他的機房因此無法彼此通訊。在這種情況之下，我們稱這個機房為critical的。現在你的任務就是寫一個程式幫助該公司的工程師找出在他們的系統中有多少個critical的機房。 Input Format輸入包含多組測試資料。每組測試資料的第一列有一個整數N（N&lt;100）。接下來最多有N列，每列的第一個整數代表某一機房的編號，而接下來的整數則代表與此機房有直接連接的機房編號。當遇到謹含一個0的一列就代表此組測試資料結束。以Sample Input中的第一組測試資料為例說明：此例共有(5,1),(5,2),(5,3),(5,4)四個直接連線。而若以第二組測試資料為例說明：此例共有(2,1),(2,3),(5,4),(5,6),(5,2)五個直接連線。 N=0代表輸入結束。請參考Sample Input。 Output Format對每一組測試資料，請輸出一列，含有critical機房的個數。 Sample Input55 1 2 3 4062 1 35 4 6 200 Sample Output12 UVa - 315翻譯來源：Luckycat Solution這題需要用到「割點」的概念，以及Tarjan Algorithm。以下是推薦的教學影片 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: 315 - Network.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Sat Dec 30 18:02:09 2017*************************************************************************/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int N, dfs_time, ans;int _time[101], _low[101];vector&lt;int&gt; link[101];void dfs(int input, int parent) &#123; int child = 0; int next, size; bool add = false; size = link[input].size(); _time[input] = _low[input] = dfs_time++; for (int i = 0; i &lt; size; i++) &#123; next = link[input][i]; if (!_time[next]) &#123; child++; dfs(next, input); _low[input] = min(_low[input], _low[next]); if (_time[input] &lt;= _low[next]) add = true; &#125;else if (next != parent) _low[input] = min(_low[input], _time[next]); &#125; if ((child &gt;= 2 || parent) &amp;&amp; add) ans++;&#125;int main() &#123; string line; int a, b; while (scanf("%d ", &amp;N) &amp;&amp; N) &#123; for (int i = 0; i &lt;= N; i++) &#123; _time[i] = _low[i] = 0; link[i].clear(); &#125; while (getline(cin, line)) &#123; stringstream ss(line); ss &gt;&gt; a; if (!a) break; while (ss &gt;&gt; b) &#123; link[a].push_back(b); link[b].push_back(a); &#125; &#125; dfs_time = 1; ans = 0; dfs(1, 0); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Articulation Points</tag>
        <tag>Tarjan Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces. Round 502]]></title>
    <url>%2F2018%2F08%2F09%2FCodeForces-Round-502%2F</url>
    <content type="text"><![CDATA[比賽連結：CodeForces Round #502以下為我個人的解法，在優化上不一定做得很好。 Problem A水題。對每筆資料進行Sorting，再用O(n)的方式找答案即可。時間複雜度：$O(nlogn)$ 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int n[1001]; int a, b, c, d, tmp; int e; cin &gt;&gt; e; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; n[i] = a + b + c + d; if (!i) tmp = n[i]; &#125; sort(n, n + e, cmp); for (int i = 0; i &lt; e; i++) if (n[i] == tmp) &#123; cout &lt;&lt; i + 1 &lt;&lt; '\n'; return 0; &#125; return 0;&#125; Problem B這題可拆成四個狀態。 1234A == 1 &amp;&amp; B == 1A == 0 &amp;&amp; B == 0A == 1 &amp;&amp; B == 0A == 0 &amp;&amp; B == 1 分別紀錄四種狀態，再用乘法解決即可。要注意需使用long long int 64位元整數型態時間複雜度：$O(n)$ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;string a, b;long long stat[4];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int n; cin &gt;&gt; n; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i]) &#123; if (a[i] == '1') //1 1 stat[0]++; else stat[1]++; // 0 0 &#125;else &#123; if (a[i] == '1') // 1 0 stat[2]++; else stat[3]++; // 0 1 &#125; &#125; long long int ans = 0; ans = stat[0] * stat[1]; ans += stat[2] * stat[1]; ans += stat[2] * stat[3]; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125; Problem C這題是比較偏向數學的題目，解釋起來有點麻煩，以下會列出前10個答案，應該可以推論出規律。時間複雜度：$O(n)$ 1234567891011 23 1 23 4 1 24 5 1 2 34 5 6 1 2 37 4 5 6 1 2 37 8 4 5 6 1 2 37 8 9 4 5 6 1 2 39 10 5 6 7 8 1 2 3 4 程式碼： 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int square[318];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int n, tmp; cin &gt;&gt; n; for (int i = 1; i &lt; 318; i++) square[i] = i*i; int a = upper_bound(square, square + 318, n) - square; if (a &amp;&amp; square[a - 1] == n) a--; int res = n % a; tmp = n - res; while (res--) &#123; cout &lt;&lt; n - res &lt;&lt; ' '; &#125; while (tmp &gt; 0) &#123; for (int i = a - 1; i &gt;= 0; i--) cout &lt;&lt; tmp - i &lt;&lt; ' '; tmp -= a; &#125; cout &lt;&lt; '\n';&#125; Problem D這題首先要先注意到$ n \le 12$，所以0-1字串的組合數最多只有到$2^{12}$種。但是題目的查詢數目遠多於$2^{12}$，所以這裡要先考慮到的就是先建表及記憶化(DP)。 接下來，關於0-1字串的比對，可以想到Bitwise的方法，將0-1字串轉成二進位的數字，再用^去比對。 然後就開始用暴力搜尋，對每一種0-1字串組合去計算「價格」。時間複雜度：$O(2^{2n})$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int cnt[1 &lt;&lt; 13];int ans[1 &lt;&lt; 13][101];int cost[13];int to2(long long a) &#123; int mul = 1; int ans = 0; while (a) &#123; ans += mul * (a &amp; 1); a /= 10; mul *= 2; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int n, m, q; long long a, b; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = n - 1; i &gt;= 0; i--) cin &gt;&gt; cost[i]; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a; cnt[to2(a)]++; &#125; int MAX = 1 &lt;&lt; n; for (int i = 0; i &lt; MAX; i++) &#123; for (int j = 0; j &lt; MAX; j++) &#123; if (!cnt[j]) continue; int tmp = i ^ j; int sum = 0; for (int k = 0; k &lt; n; k++) &#123; if (!(tmp &amp; (1 &lt;&lt; k))) sum += cost[k]; &#125; if (sum &gt; 100) continue; ans[i][sum] += cnt[j]; &#125; for (int j = 1; j &lt;= 100; j++) ans[i][j] += ans[i][j - 1]; &#125; while (q--) &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; ans[to2(a)][b] &lt;&lt; '\n'; &#125; return 0;&#125; 以上就是我比賽時AC的題目。]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Bitwise</tag>
        <tag>CodeForces</tag>
        <tag>Sort</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Binary Index Tree]]></title>
    <url>%2F2018%2F08%2F08%2FTemplate-Binary-Index-Tree%2F</url>
    <content type="text"><![CDATA[Fendwick Tree，區間查詢和，支援修改。 Code123456789101112131415161718#define maxn 1000int tree[maxn + 1], num[maxn + 1];void init() &#123; memset(tree, 0, sizeof(tree)); for (int i = 1; i &lt;= maxn; i++) for (int j = i; j &lt;= maxn; j += i &amp; -i) tree[j] += num[i];&#125;int query(int i) &#123; int ans = 0; for (; i; i -= i &amp; -i) ans += tree[i]; return ans;&#125;void modify(int i, int d) &#123; for (; i &lt;= maxn; i += i &amp; -i) tree[i] += d;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Disjoint set]]></title>
    <url>%2F2018%2F08%2F07%2FTemplate-Disjoint-set%2F</url>
    <content type="text"><![CDATA[Disjoint set並查集。 Code12345678910111213141516171819#define maxn 1000struct Disjoint &#123; int p[maxn]; void init() &#123; for (int i = 0; i &lt; maxn; i++) p[i] = i; &#125; int parent(int i) &#123; if (p[i] == i) return i; return p[i] = parent(p[i]); &#125; void connect(int a, int b) &#123; p[parent(b)] = parent(a); &#125; bool same(int a, int b) &#123; return(parent(a) == parent(b)); &#125;&#125;;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Disjoint set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template. Segment Tree]]></title>
    <url>%2F2018%2F08%2F07%2FTemplate-Segment-Tree%2F</url>
    <content type="text"><![CDATA[區間查詢最大值線段樹，支援單點、範圍修改，使用Lazy flag優化。 Code12345678910111213141516171819202122232425262728293031323334353637#define maxn 1000struct node &#123; int data, lazy;&#125;tree[maxn * 4];int num[maxn];// root = 0int make_tree(int l, int r, int index) &#123; tree[index].lazy = 0; if (l == r) return tree[index].data = num[l]; int m = (l + r) &gt;&gt; 1; int index2 = index &lt;&lt; 1; return tree[index].data = max(make_tree(l, m, index2 + 1), make_tree(m + 1, r, index2 + 2));&#125;int query(int l, int r, int s, int e, int index) &#123; if (l &gt; e || r &lt; s) return -10000000; if (s &lt;= l &amp;&amp; r &lt;= e) return tree[index].data + tree[index].lazy; int m = (l + r) &gt;&gt; 1; int index2 = index &lt;&lt; 1; return max(query(l, m, s, e, index2 + 1), query(m + 1, r, s, e, index2 + 2)) + tree[index].lazy;&#125;void modify(int l, int r, int s, int e, int index, int dx) &#123; if (l &gt; e || r &lt; s) return; if (s &lt;= l &amp;&amp; r &lt;= e) tree[index].lazy += dx; else &#123; int m = (l + r) &gt;&gt; 1; int index2 = index &lt;&lt; 1; modify(l, m, s, e, index2 + 1, dx); modify(m + 1, r, s, e, index2 + 2, dx); tree[index].data = max(tree[index2 + 1].data + tree[index2 + 1].lazy, tree[index2 + 2].data + tree[index2 + 2].lazy); &#125;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 13153. Number of Connected Components]]></title>
    <url>%2F2018%2F08%2F07%2FUVa-13153-Number-of-Connected-Components%2F</url>
    <content type="text"><![CDATA[Description給你 N 個節點，每個點上附有一個介於$1～10^6$之間的正整數。假如某2個節點上的數其最大公因數（GCD）大於1，則這2個節點之間會有一條邊存在。要請你算出這N個節點構成的的圖形中，共有幾個連通的單元。 Input Format輸入的第一列有一個正整數t代表以下有幾筆測資。（$t \le 100$）每筆測資的第一列，有一個正整數 N（$1 \le N \le 10^5$），代表節點的數目。接下來的一列含有N個正整數，代表這N個節點上面附帶的數。 Output Format對每筆測資輸出一列，先輸出這是第幾筆測資，然後輸出這N個節點構成的圖形中，共有幾個連通的單元。 Sample Input232 3 462 3 4 5 6 6 Sample OutputCase 1: 2Case 2: 2 UVa - 13153翻譯來源：Luckycat Solution這題有兩個想法，第一就是對點$i, j(i,j \in 輸入 \text{ 且 } i \neq j)$ 去做Disjoint set，時間複雜度為$O(N^2)$。如果是這樣做的話，一定會TLE，所以我們要去思考另一種做法：題目是跟我們說 $\text{最大公因數} &gt; 1$的兩點要連起來，不妨試試將點和點的連接換成質數的連接，每輸入一個數字n，就將n所有的質因數連起來，輸入結束之後再算共有幾個集合即可。注意！題目有可能會輸入重複數字，若為1，則需特別考慮。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/************************************************************************* &gt; File Name: 13153 - Number of Connected Components.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Tue Jul 24 19:59:14 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;bool tmp[1000000];int parent[1000000];vector&lt;int&gt; p;int usenum[1000000];int n, cnt, size, num;int find_parent(int i) &#123; if (i == parent[i]) return i; return parent[i] = find_parent(parent[i]);&#125;void connect(int a, int b) &#123; int pa = find_parent(a); int pb = find_parent(b); if (pa == pb) return; parent[pb] = pa;&#125;void factorization(int i) &#123; int first = 0; int a = 2; for (int j = 0; a &lt;= sqrt(i); a = p[++j]) if (!(i % a)) &#123; if (!tmp[a]) &#123; usenum[num++] = a; parent[a] = a; &#125; tmp[a] = 1; if (!first) first = a; else &#123; connect(first, a); &#125; while (!(i % a)) i /= a; &#125; if (i &gt; 1) &#123; if (!tmp[i]) &#123; usenum[num++] = i; parent[i] = i; &#125; tmp[i] = 1; if (first) connect(first, i); &#125;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); tmp[2] = 1; p.push_back(2); for (int i = 3; i &lt; 1000; i += 2) &#123; if (tmp[i]) continue; p.push_back(i); for (int j = i &lt;&lt; 1; j &lt; 1000; j += i) tmp[j] = 1; &#125; p.push_back(1 &lt;&lt; 30); int c; cin &gt;&gt; c; for (int i = 1; i &lt;= c; i++) &#123; cin &gt;&gt; n; memset(tmp, 0, sizeof(tmp)); num = cnt = 0; while (n--) &#123; int i; cin &gt;&gt; i; if (i == 1) cnt++; else factorization(i); &#125; for (int i = 0; i &lt; num; i++) &#123; int t; if (tmp[t = find_parent(usenum[i])]) tmp[t] = 0, cnt++; &#125; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ": " &lt;&lt; cnt &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint set</tag>
        <tag>Prime factor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 571. Jugs]]></title>
    <url>%2F2018%2F08%2F06%2FUVa-571-Jugs%2F</url>
    <content type="text"><![CDATA[Description在電影「終極警探 3（Die Hard 3）」中布魯斯威利（Bruce Willis）和山謬傑克森（Samuel L. Jackson）遇到壞蛋設下的謎題：給一個3加侖和5加侖的桶子，要求他們必須在5加侖的桶子中裝4加侖的水。現在你的任務就是解決這個問題。 給你2個桶子A、B和無限供應的水，你可以做3個動作： 把一個桶子裝滿水。 把一個桶子的水倒光。 把一個桶子的水倒到另一個桶子中。 把水從一個桶子倒到另一個桶子的動作停止有2個可能的原因：第一個桶子的水倒光了或第二個桶子的水滿了。例如：A有5加侖的水，B有6加侖的水且B的容量為8加侖，則當把A的水倒到B後，B就滿了（8加侖）而A中還剩3加侖。在本問題中，給你Ca,Cb,N。Ca,Cb分別代表A桶子和B桶子的容量而N是我們要求的目標。我們希望你的程式輸出一連串的動作之後，可以得到N加侖的水（不論在A或B中都可以）。這一連串的動作包含： fill A fill B empty A empty B pour A B pour B A success 在這裡，&quot;pour A B&quot;代表把A的水倒到B中，而&quot;success&quot;代表任務已經完成了。你可以假設給你的輸入一定有解答。 Input Format每組測試資料一列，含有3個正整數Ca,Cb,N。（ $0 &lt; \textrm{Ca} \le \textrm{Cb}，\textrm{N} \le \textrm{Cb} \le 1000$ ） Output Format每組測試資料輸出一連串的動作（總是以success作為結束），使得可以得到N加侖的水（不論在A或B中都可以）。請參考Sample Output。 Sample Input3 5 45 7 31 1 1 Sample Outputfill Bpour B Aempty Apour B Afill Bpour B Asuccessfill Apour A Bfill Apour A Bsuccessfill Asuccess UVa - 571翻譯來源：Luckycat Solution這題可以利用BFS來做，每次都模擬6種操作，直到達成目標為止。本題利用STL容器的Queue來模擬BFS。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/************************************************************************* &gt; File Name: 571 - Jugs.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Mon Jan 22 20:09:12 2018*************************************************************************/#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int A, B; vector&lt;int&gt; moves;&#125;;bool state[1005][1005];/* * 0 -&gt; A fill * 1 -&gt; B fill * 2 -&gt; A -&gt; B * 3 -&gt; B -&gt; A * 4 -&gt; A empty * 5 -&gt; B empty*/void out(int in) &#123; switch (in) &#123; case 0: cout &lt;&lt; "fill A" &lt;&lt; '\n'; break; case 1: cout &lt;&lt; "fill B" &lt;&lt; '\n'; break; case 2: cout &lt;&lt; "pour A B" &lt;&lt; '\n'; break; case 3: cout &lt;&lt; "pour B A" &lt;&lt; '\n'; break; case 4: cout &lt;&lt; "empty A" &lt;&lt; '\n'; break; case 5: cout &lt;&lt; "empty B" &lt;&lt; '\n'; break; &#125;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int a, b, n; while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; n) &#123; node now, tmp; queue&lt;node&gt; que; now.A = now.B = 0; que.push(now); for (int i = 0; i &lt; 1005; i++) for (int j = 0; j &lt; 1005; j++) state[i][j] = 1; while (!que.empty()) &#123; now = que.front(); que.pop(); if (now.B == n) break; for (int i = 0; i &lt; 6; i++) &#123; tmp = now; tmp.moves.push_back(i); switch (i) &#123; case 0: if (now.A &lt; a) &#123; tmp.A = a; que.push(tmp); if (state[tmp.A][tmp.B]) &#123; que.push(tmp); state[tmp.A][tmp.B] = 0; &#125; &#125; break; case 1: if (now.B &lt; b) &#123; tmp.B = b; if (state[tmp.A][tmp.B]) &#123; que.push(tmp); state[tmp.A][tmp.B] = 0; &#125; &#125; break; case 2: if (now.B &lt; b &amp;&amp; now.A &gt; 0) &#123; tmp.B += tmp.A; tmp.A = 0; if (tmp.B &gt; b) tmp.A = tmp.B - b, tmp.B = b; if (state[tmp.A][tmp.B]) &#123; que.push(tmp); state[tmp.A][tmp.B] = 0; &#125; &#125; break; case 3: if (now.A &lt; a &amp;&amp; now.B &gt; 0) &#123; tmp.A += tmp.B; tmp.B = 0; if (tmp.A &gt; a) tmp.B = tmp.A - a, tmp.A = a; if (state[tmp.A][tmp.B]) &#123; que.push(tmp); state[tmp.A][tmp.B] = 0; &#125; &#125; break; case 4: if (now.A &gt; 0) &#123; tmp.A = 0; if (state[tmp.A][tmp.B]) &#123; que.push(tmp); state[tmp.A][tmp.B] = 0; &#125; &#125; break; case 5: if (now.B &gt; 0) &#123; tmp.B = 0; if (state[tmp.A][tmp.B]) &#123; que.push(tmp); state[tmp.A][tmp.B] = 0; &#125; &#125; break; &#125; &#125; &#125; int size = now.moves.size(); for (int i = 0; i &lt; size; i++) out(now.moves[i]); cout &lt;&lt; "success\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 307. Sticks]]></title>
    <url>%2F2018%2F08%2F06%2FUVa-307-Sticks%2F</url>
    <content type="text"><![CDATA[DescriptionGeorge 拿了一些相同長度的棍子，然後隨意的把這些棍子切成一段一段的棍子（每段長度都不會超過 50 個單位長）。現在他想要把這些一段一段的棍子拼回原來的樣子，但是他忘了他原來帶多少根棍子來，並且也忘了原來每根棍子的長度。請幫助他設計一個程式算出這些棍子原來可能的最小長度。所有的棍子長度都是整數，並且大於 0。 Input Format輸入含有多組測試資料。每組測試資料2列，第一列有一個整數 n 代表切後棍子的數目。第二列含有 n 個整數，分別代表這 n 支棍子的長度。當 n=0 時代表輸入結束。 Output Format對於每一列測試資料，輸出這些棍子原來可能的最小長度。 Sample Input95 2 1 5 2 1 5 2 141 2 3 40 Sample Output65 UVa - 307翻譯來源：Luckycat Solution這題首先要考慮到「最小長度」所代表的意義，令最小長度為i、竿子長度總和sum目前已知：$i \in \lbrace x | 單一竿子最大長度 \le x \le sum \rbrace $則可推論出以下結果 i絕對可以整除sum 若 i &gt; sum/2，則i必定為sum 利用以上推論結果去做DFS即可。為了減少運算次數，所以會先取長度較長的竿子，這點需要注意。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/************************************************************************* &gt; File Name: 00307 - Sticks.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Fri Jun 29 12:16:42 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;int n;int sticks[100];bool use[100];int len, sum;bool cmp(int a, int b) &#123; return a &gt; b;&#125;bool dfs(int i, int l, int r) &#123; if (!l) &#123; r -= len; if (!r) return true; for (i = 0; i &lt; n &amp;&amp; use[i]; i++); use[i] = 1; if (dfs(i, len - sticks[i], r)) return true; use[i] = 0; return false; &#125; while (++i &lt; n) &#123; if (i &amp;&amp; sticks[i - 1] == sticks[i] &amp;&amp; !use[i - 1]) continue; if (sticks[i] &gt; l || use[i]) continue; use[i] = 1; if (dfs(i, l - sticks[i], r)) return true; use[i] = 0; if (sticks[i] == l) break; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); while (cin &gt;&gt; n &amp;&amp; n) &#123; sum = 0; bool flag = 1; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; sticks[i]; sum += sticks[i]; &#125; memset(use, false, sizeof(use)); sort(sticks, sticks + n, cmp); for (len = sticks[0]; len &lt;= sum / 2 &amp;&amp; flag; len++) &#123; if (sum % len) continue; if (dfs(-1, len, sum)) flag = 0; &#125; cout &lt;&lt; (flag ? sum : len - 1) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch Linux Installation Guide]]></title>
    <url>%2F2018%2F08%2F06%2FArch-Linux-Installation-Guide%2F</url>
    <content type="text"><![CDATA[驗證開機模式、磁碟分割驗證是否為UEFI開機模式:# ls /sys/firmware/efi/efivars 若Terminal反應No such file or directory代表並非UEFI開機模式 顯示硬碟分割區# fdisk -l 分割硬碟# gdisk /dev/sdx 格式化、裝載磁碟格式化:# mkfs.ext4 [root partition] 若要使用雙系統，不能格式化efi boot partition，請略過下面該行指令 # mkfs.fat -F 32 [efi boot partition] 裝載磁碟# mount [root partition] /mnt # mkdir /mnt/boot # mount [efi boot partition] /mnt/boot 安裝作業系統、磁碟裝載檔案# vim /etc/pacman.d/mirrorlist (更改mirror檔案，加快下載) # pacstrap /mnt base base-devel grub sudo vim # genfstab -U /mnt &gt;&gt; /mnt/etc/fstab (use -U or -L to define by UUID or labels, respectively) 設定系統# arch-chroot /mnt (切換root) [root@arch /]# ln -s /usr/share/zoneinfo/Asia/Taipei /etc/localtime (設定timezone) [root@arch /]# vim /etc/locale.gen (註解掉 兩行en_US，以及三行zh_TW) [root@arch /]# echo LANG=en_US.UTF-8 &gt; /etc/locale.conf [root@arch /]# locale-gen (設定語言) [root@arch /]# echo [hostname] &gt; /etc/hostname (設定電腦名稱) [root@arch /]# passwd [root@arch /]# useradd -mg users -G wheel,storage,power -s /bin/bash [user name] [root@arch /]# vim /etc/sudoers (更改root密碼、新增使用者、且在/etc/sudoers裡面取消註解%wheel ALL該行) 安裝Bootloader[root@arch /]# pacman -S grub efibootmgr os-prober [root@arch /]# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub [root@arch /]# grub-mkconfig -o /boot/grub/grub.cfg 結束[root@arch /]# exit # umount -R /mnt # reboot 額外設定yaourt# git clone https://aur.archlinux.org/package-query.git # cd package-query # makepkg -si --noconfirm # git clone https://aur.archlinux.org/yaourt.git # cd yaourt # makepkg -si --noconfirm # cd ~ # rm -rf package-query Gnome# pacman -S xorg # pacman -S gnome # systemctl [enable/start] gdm Internetwifi-menu# pacman -S wpa_supplicant dialog Auto connect to wifi須事先使用wifi-menu連接網路產生profile # netctl enable [Profile] Ethernet# systemctl enable dhcpcd 中文輸入# sudo pacman -S fcitx-im fcitx-chewing fcitx-configtool # sudo vim /etc/environment 加入以下3行 GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=&quot;@im=fcitx&quot; 安裝過程錄影]]></content>
      <categories>
        <category>教學</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 103. Stacking Boxes]]></title>
    <url>%2F2018%2F08%2F06%2FUVa-103-Stacking-Boxes%2F</url>
    <content type="text"><![CDATA[Description在數學或電腦科學裡，有些概念在一維或二維時還蠻簡單的，但到 N 維就會顯得非常複雜。試想一個 n 維的「盒子」：在二維空間裡，盒子 ( 2 , 3 ) 可代表一個長為 2 個單位，寬為 3 個單位的盒子；在三維空間裡，盒子 ( 4 , 8 , 9 ) 則是一個 4*8*9（長、寬、高）的盒子。至於在六維空間裡，也許我們不清楚 ( 4 , 5 , 6 , 7 , 8 , 9 ) 長得怎樣，不過我們還是可以分析這些盒子的特性。 在此問題裡，我們要算出一組 n 維盒子裡，它們的「最長套入串列」： $b_1, b_2, ......, b_k$，其中每個盒子 $b_i$ 都可以「放入」盒子 $b_{i+1}$ 中（$1 \le i &lt; k$）考慮兩個盒子 D =（ $d_1, d_2, ......, d_n$ ）， E =（ $e_1, e_2, ......, e_n$ ）。如果盒子 D 的 n 個維，能夠存在一種重排，使得重排後， D 每一維的量度都比 E 中相對應的維的量度還要小，則我們說盒子 D 能「放入」盒子 E 。（用比較不嚴謹的講法，這就好像我們將盒子 D 翻來翻去，看看能不能擺到 E 裡面去。不過因為我們考慮的是任一重排，所以實際上盒子不只可轉來轉去，甚至還可以扭曲。）（還是看看下面的例子說明好了）。譬如說，盒子 D = ( 2 , 6 ) 能夠被放入盒子 E = ( 7 , 3 ) 裡，因為 D 可以重排變為 ( 6 , 2 ) ，這樣子 D 的每個維的量度都比 E 裡對應的維還要小。而盒子 D = ( 9 , 5 , 7 , 3 ) 就沒辦法放進盒子 E = ( 2 , 10 , 6 , 8 ) ，因為就算再怎摸重排 D 裡的維，還是沒辦法符合「放入」的條件。不過 F = ( 9 , 5 , 7 , 1 ) 就可以放入 E 了，因為 F 可以重排成 ( 1 , 9 , 5 , 7 ) ，這樣就符合了放入的條件。我們今定義「放入」如下：對於任兩個盒子 D =（ $d_1, d_2, ......,d_n$）和 E =（ $e_1, e_2, ......,e_n$ ），如果存在一種 1..n 的重排π，使得對於任何的 $1 \le i \le n$，皆有 $d_{π(i)} &lt; e_i$，則我們說盒子 D 能「放入」盒子 E 。 Input Format輸入包含多組測試資料。每組測試資料的第一列有兩個數字：第一個是盒子的數量 k ，然後是盒子的維數 n 。接下來有 k 列，每列有n個整數表示一個盒子的 n 個維的量度，量度之間由一個以上的空白做區隔。第一列表示第一個盒子，第二列表示第二個盒子，依此類推。此問題裡，盒子的維數最小是 1 ，最大是 10 ， 並且每組測試資料中盒子的個數最多為 30 個。 Output Format對於每一組測試資料，你必須輸出兩列數字：第一列是「最長套入串列」的長度，第二列是按照內外順序，印出「最長套入串列」裡盒子的編號（其中編號是按照在輸入檔案的每組數列裡所出現的順序，例如第一個盒子就是 1 號 . . . 等等。）最裡面的盒子（或是最小的）擺在第一個，再來是次小的，依此類推。如果對於每一組的盒子，存在兩個以上的「最長套入串列」，輸出任何一個均可。 Sample Input5 23 78 105 29 1121 188 65 2 20 1 30 1023 15 7 9 11 340 50 34 24 14 49 10 11 12 13 1431 4 18 8 27 1744 32 13 19 41 191 2 3 4 5 680 37 47 18 21 9 Sample Output53 1 2 4 547 2 5 6 UVa - 103翻譯來源：Luckycat Solution這題其實就是經典的LIS變形題目，首先我們要對每一個箱子的維度進行排序，可以用簡單邏輯得知由小到大排是最佳方式。接著我們再對各箱子進行排序，排序是利用字典大小的方法排，這樣就解決了！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************************* &gt; File Name: 00103 - Stacking Boxes.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Sat 4/21 19:23:24 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;int k, n;struct objects &#123; int length[12]; int num; bool operator &lt; (objects const &amp;b) const &#123; for (int i = 0; i &lt; n; i++) if (!(length[i] &lt; b.length[i])) return 0; return 1; &#125;&#125;input[35];int dp[35];int previous[31];int ans;void trace(int i) &#123; if (previous[i] != -1) trace(previous[i]); cout &lt;&lt; input[i].num; if (--dp[ans]) cout &lt;&lt; ' '; else cout &lt;&lt; '\n';&#125;bool cmp(objects a, objects b) &#123; for (int i = 0; i &lt; n; i++) &#123; if (a.length[i] &lt; b.length[i]) return 1; if (a.length[i] &gt; b.length[i]) return 0; &#125; return 0;&#125;int main() &#123; while (cin &gt;&gt; k &gt;&gt; n) &#123; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; n; j++) cin &gt;&gt; input[i].length[j]; input[i].num = i + 1; sort(input[i].length, input[i].length + n); &#125; for (int i = 0; i &lt; k; i++) dp[i] = 1; sort(input, input + k, cmp); for (int i = 0; i &lt; k; i++) previous[i] = -1; for (int i = 0; i &lt; k; i++) for (int j = i + 1; j &lt; k; j++) if (input[i] &lt; input[j] &amp;&amp; dp[i] + 1 &gt; dp[j]) &#123; dp[j] = dp[i] + 1; previous[j] = i; &#125; ans = 0; for (int i = 1; i &lt; k; i++) if (dp[ans] &lt; dp[i]) ans = i; cout &lt;&lt; dp[ans] &lt;&lt; '\n'; trace(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dynamic Programming</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa 10952. Pattern Transformations]]></title>
    <url>%2F2018%2F08%2F06%2FUVa-10952-Pattern-Transformations%2F</url>
    <content type="text"><![CDATA[DescriptionConsider the two patterns of ‘O’ and ‘X’ below (‘.’ represent an empty square). We want the first pattern to be transformed into the second pattern in one time unit. During this time unit, each symbol (‘O’ and ‘X’) can move one step in any of the four directions (or remain at its current square). All movements happen simultaneously, so a symbol can move to an occupied square, if that symbol is moved to some other square. If a symbol moves from square A to B, and the symbol at B moves to A, we have a swap. Write a program which calculates the least number of swaps needed to transform a given pattern into another given pattern. .XO.. ..XO. ..OX. .XX.. .XX.. ..OX. To transform the first pattern above into the second one requires one swap: The two symbols in the first line are moved to the right, the ‘O’ in the second line must be swapped with the ‘X’ below. The other two ‘X’ are moved up and down, respectively. Input FormatThe first line in the input contains the number of test cases to follow (at most 20). Each test case starts with a line containing two integers, w and h ($1 \le w, h \le 8$), the width and height of the two patterns. Then follow h lines describing each row of the two patterns (the two patterns will be separated with a single space, see the sample input). The only allowed characters in the patterns will be the symbols ‘O’, ‘X’ and ‘.’. Output FormatFor each input you should output a line containing a single integer: the least number of swaps required to transform the first pattern into the second. If the transformation is not possible, output a ‘-1’. Sample Input3 5 3 .XO.. ..XO. ..OX. .XX.. .XX.. ..OX. 4 4 OXOX XOXO XX.O OX.X O..X X..O XOXO OXOX 3 4 .X. .X. .OX XO. ..O .O. ... ... Sample Output0 0 -1 UVa - 10952 Solution這題令我印象最深刻的就是我是這題的Topcoder：AC 0.000sec。 這題主要是考驗如何以bit來表示狀態，以及在寫狀態轉移式時的細心程度，再利用DFS來達成搜尋目的。在我的程式裡面，共有四個狀態，分別是當前垂直、水平改變，以及上一行的垂直、水平改變。以水平為例，第i位的0代表未有O或X移動到第i位置，若是1則相反。若是垂直的狀態，1則代表有往下移動。若只以上述的想法來寫，會TLE，所以需要以DP的方式將重複狀態的DFS記錄下來（下面程式的38~41行）。注意！此題第一測資答案為0，在上方已修正 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/************************************************************************* &gt; File Name: 10952 - Pattern Transformations.cpp &gt; Author: Samuel &gt; Mail: enminghuang21119@gmail.com &gt; Created Time: Sat Jul 28 11:22:06 2018*************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 1 &lt;&lt; 30;int n, m, c;char s[8][8], e[8][8];int dp[8][1 &lt;&lt; 8][1 &lt;&lt; 8], run[8][1 &lt;&lt; 8][1 &lt;&lt; 8];int dfs(int, int, int, int, int, int);int sol(int, int, int);int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; c; while (c--) &#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) cin &gt;&gt; s[i][j]; for (int j = 0; j &lt; m; j++) cin &gt;&gt; e[i][j]; &#125; int ans = sol(0, 0, (1 &lt;&lt; m) - 1); cout &lt;&lt; (ans == inf ? -1 : ans) &lt;&lt; '\n'; &#125; return 0;&#125;int sol(int row, int prev_ver, int prev_hor) &#123; //垂直 平行 if (row == n) return (!prev_ver &amp;&amp; prev_hor == (1 &lt;&lt; m) - 1) ? 0 : inf; if (run[row][prev_ver][prev_hor] == c) return dp[row][prev_ver][prev_hor]; run[row][prev_ver][prev_hor] = c; return dp[row][prev_ver][prev_hor] = dfs(row, 0, prev_ver, prev_hor, 0, 0);&#125;int dfs(int row, int col, int prev_ver, int prev_hor, int now_ver, int now_hor) &#123; while (1) &#123; int re = inf; int col1 = 1 &lt;&lt; col; if (col == m) &#123; if (prev_hor != (1 &lt;&lt; m) - 1) return inf; for (int i = 0; i &lt; m; i++) if (e[row][i] == '.') now_hor |= 1 &lt;&lt; i; return sol(row + 1, now_ver, now_hor); &#125; if (prev_ver &amp; col1) &#123; if (now_hor &amp; col1) return inf; now_hor |= col1; &#125; if (s[row][col] == '.') &#123; if (!(prev_hor &amp; col1)) return inf; if (e[row][col] == '.') now_hor |= col1; col++; continue; &#125; if (!(prev_hor &amp; col1)) &#123; if (s[row][col] != e[row - 1][col]) return inf; if (prev_ver &amp; col1) return 1 + dfs(row, col + 1, prev_ver, prev_hor | col1, now_ver, now_hor); prev_hor |= col1; col++; continue; &#125; if (s[row][col] == e[row][col] &amp;&amp; !(prev_ver &amp; col1) &amp;&amp; !(now_hor &amp; col1)) re = min(re, dfs(row, col + 1, prev_ver, prev_hor, now_ver, now_hor | col1)); if (col &lt; m - 1 &amp;&amp; s[row][col] == e[row][col + 1]) re = min(re, dfs(row, col + 1, prev_ver, prev_hor, now_ver, now_hor | (col1 &lt;&lt; 1))); if (col &amp;&amp; s[row][col] == e[row][col - 1] &amp;&amp; !(now_hor &amp; (col1 &gt;&gt; 1))) &#123; if (!(prev_ver &amp; col1) &amp;&amp; (now_hor &amp; col1)) re = min(re, 1 + dfs(row, col + 1, prev_ver, prev_hor, now_ver, now_hor | (col1 &gt;&gt; 1))); else re = min(re, dfs(row, col + 1, prev_ver, prev_hor, now_ver, now_hor | (col1 &gt;&gt; 1))); &#125; if (row &lt; n - 1 &amp;&amp; s[row][col] == e[row + 1][col]) re = min(re, dfs(row, col + 1, prev_ver, prev_hor, now_ver | col1, now_hor)); return re; &#125;&#125;]]></content>
      <categories>
        <category>題解</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Bitwise</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp教學]]></title>
    <url>%2F2018%2F08%2F05%2FCpp%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[C++語言自學手冊 是我自己撰寫的自學手冊，裡面是從零基礎開始教起的，不需要任何程式基礎。另外，後面還有演算法的入門教學，這部分與C++語言較無關聯，但是在程式競賽裡面是最重要的部分。]]></content>
      <categories>
        <category>連結</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
