<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Samuel&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://samuel21119.github.io/"/>
  <updated>2019-06-29T05:12:19.023Z</updated>
  <id>http://samuel21119.github.io/</id>
  
  <author>
    <name>Samuel Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>T-Rex Runner with Keras</title>
    <link href="http://samuel21119.github.io/2019/06/06/T-Rex-Runner-with-Tensorflow/"/>
    <id>http://samuel21119.github.io/2019/06/06/T-Rex-Runner-with-Tensorflow/</id>
    <published>2019-06-06T13:07:08.000Z</published>
    <updated>2019-06-29T05:12:19.023Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/06/06/T-Rex-Runner-with-Tensorflow/run.gif" title="AI遊玩畫面"><p>「無法連上網際網路」畫面的小恐龍一直是Chrome的小彩蛋，而這裡使用了神經網路+Q-learning，讓AI去學習玩這個遊戲。<a id="more"></a></p><h1 id="Q-learning介紹"><a href="#Q-learning介紹" class="headerlink" title="Q-learning介紹"></a>Q-learning介紹</h1><p>Q-learning是強化學習(Reinforcement Learning)中的一種。舉個例子來看：有個小朋友在練習走路，如果往前走了一步，父母就會給他糖果；反之則無。<br>而這個程式也是一樣，利用強化學習的方式，讓程式在沒有監督的環境下，能夠自己找出讓小恐龍存活、得到最高獎賞的方法。  </p><p>而Q-learning是沒有模型的強化學習，說簡單點，就是因為我們不知道要怎麼建立模型的情況，所以我們自己定義每種「行動」(跳跟不跳)的「獎賞」，並且判斷當前「狀態」做的「行動」會不會導致小恐龍死掉，讓程式自己去挖掘在這個情況下到底要不要往上跳。  </p><p>經過Q-learning的方法學習後，會產生類似下圖的表格(在這裡我們的「狀態」就是遊戲截圖)：<img src="1.gif" alt=""><br>對於每種狀態，會對應到一個動作，而因為我們只分成跳跟不跳，所以只有0和1。  </p><p>而在這個模型裡面，有兩個很重要。其中一個是名叫epsilon($\epsilon$)的函數，我們引入了$\epsilon$函數來決定部分行動的隨機性，然後再逐漸降低$\epsilon$減少隨機動作的發生，最後讓模型去挖掘最好的最好得到獎賞的動作。另一個就是$\gamma$(Discount Factor)，$\gamma$決定了程式做出動作時要看多遠，因為小恐龍在無障礙物時跳起來可能會在之後掉到仙人掌上面，而在這程式裡面$\gamma=0.99$時，模型能夠辨認上述所遇到的問題、知道在半空中沒辦法二連跳。</p><h1 id="遊戲模組"><a href="#遊戲模組" class="headerlink" title="遊戲模組"></a>遊戲模組</h1><p>此程式利用了Selenium模組使Python能與Firefox溝通，並利用Pillow和OpenCV來處理影像。</p><h1 id="遊戲處理"><a href="#遊戲處理" class="headerlink" title="遊戲處理"></a>遊戲處理</h1><h2 id="修改遊戲"><a href="#修改遊戲" class="headerlink" title="修改遊戲"></a>修改遊戲</h2><p>為了簡化我們的模型，我們簡化了原始的遊戲，使之背景不會變成夜晚、遊戲速度不會加快。</p><h2 id="處理影像"><a href="#處理影像" class="headerlink" title="處理影像"></a>處理影像</h2><p>此遊戲的截圖解析度是$1200\times 300$，而這裡把圖片裁切並壓縮成4個$80\times80$的圖片並丟入神經網路裡做運算。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>Github: <a href="https://github.com/samuel21119/T-Rex-Runner" target="_blank" rel="noopener">samuel21119/T-Rex-Runner</a><br>T-Rex 遊戲網址: <a href="https://samuel21119.github.io/t-rex">samuel21119.github.io/t-rex</a></p><h1 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h1><ul><li><a href="https://medium.com/acing-ai/how-i-build-an-ai-to-play-dino-run-e37f37bdf153" target="_blank" rel="noopener">How I built an AI to play Dino Run</a></li><li><a href="https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf" target="_blank" rel="noopener">Playing Atari with Deep Reinforcement Learning</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/06/06/T-Rex-Runner-with-Tensorflow/run.gif&quot; title=&quot;AI遊玩畫面&quot;&gt;
&lt;p&gt;「無法連上網際網路」畫面的小恐龍一直是Chrome的小彩蛋，而這裡使用了神經網路+Q-learning，讓AI去學習玩這個遊戲。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://samuel21119.github.io/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://samuel21119.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>UVa 11516. WiFi</title>
    <link href="http://samuel21119.github.io/2019/02/26/UVa-11516-WiFi/"/>
    <id>http://samuel21119.github.io/2019/02/26/UVa-11516-WiFi/</id>
    <published>2019-02-26T04:00:31.000Z</published>
    <updated>2019-02-26T04:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>大街上的居民開會決定要在他們居住的街上安裝無線網路，讓無線網路環境涵蓋所有住戶，請你幫忙選擇無線網路基地台(AP)的地點，他們希望訊號愈強愈好，但他們購買AP的預算有限，在有限的AP數量之下，使得在「所有房子與其最近的AP之間的距離」中最大值，愈小愈好。<br><a id="more"></a>大街是直線的，每間房子的門牌號碼剛好等於與端點的距離，例如123號的住戶，距離大街的起點為123公尺</p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>輸入的第一列有一個整數表示測試資料的組數。<br>接下來每組測試資料的第一列有兩個正整數$n,m$，$n$ 表示居民所購買的AP總數，$m$ 表示住戶總數。<br>接下來的 $m$ 列，每列表示一個住戶的門牌號碼。大街上不超過$10^5$個住戶，且門牌號碼不超過一百萬。</p><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>請每組資料輸出一個數值，表示「所有住戶與其最近的AP間的距離」之最大值，請四捨五入到小數點下第一位。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 23 1</span><br><span class="line">3 10</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/115/11516.pdf" target="_blank" rel="noopener">11516</a><br>翻譯來源：<a href="http://luckycat.kshs.kh.edu.tw/homework/q11516.htm" target="_blank" rel="noopener">Luckycat</a></p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>這題的解法可以分成兩部分：  </p><ol><li>假設已決定所有住戶到最近基地台的最大距離，要如何檢查是否存在至少一種擺法？</li><li>要如何決定所有住戶到最近基地台的最大遠距?</li></ol><h2 id="假設已決定所有住戶到最近基地台的最大距離，要如何檢查是否存在至少一種擺法"><a href="#假設已決定所有住戶到最近基地台的最大距離，要如何檢查是否存在至少一種擺法" class="headerlink" title="假設已決定所有住戶到最近基地台的最大距離，要如何檢查是否存在至少一種擺法?"></a>假設已決定所有住戶到最近基地台的最大距離，要如何檢查是否存在至少一種擺法?</h2><p>首先先解決第一個問題。假設我從左邊一路擺AP擺到右邊，且已知最大距離為$t$，那利用貪心可推論出上第一個AP一定要擺在$第一個住戶位置+t$的地方，接著到下一個沒有被涵蓋在範圍內的住戶($位置&gt;第一個住戶位置+2t$，再用剛剛的想法一路擺下去。<br>由貪心法可知道上述的擺法一定是最佳解，所以也可以知道總共需要擺多少個AP，若AP數量超過題目給的大小，則可以知道「最大距離為$t$」不可行。</p><p><em>時間複雜度：$O(n)$</em></p><h2 id="要如何決定所有住戶到最近基地台的最大遠距"><a href="#要如何決定所有住戶到最近基地台的最大遠距" class="headerlink" title="要如何決定所有住戶到最近基地台的最大遠距?"></a>要如何決定所有住戶到最近基地台的最大遠距?</h2><p>題目會給住戶的門牌號碼，所以在最差的情況下答案就是$(最大門牌號碼-最小門牌號碼)/2$，而最佳的擺法則是$0$。<br>所以可以從$0\text{~}(最大門牌號碼-最小門牌號碼)/2$一路搜索下去。可是這樣的會時間複雜度會變成$O(n*檢查的複雜度) = O(n^2)$，很明顯地會TLE，所以需要一個比較好的方法。  </p><p>假設最大距離為$t$成立，則可以用反證法證明$t+1$時仍成立，接著用數學歸納法可得$t\text{~}(最大門牌號碼-最小門牌號碼)/2$接成立。若$t$不成立，則也可以用上述的想法推得$t-1$時也是不成立。<br>所以t從小到大，一定是類似這樣排列：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X: 不成立</span><br><span class="line">O: 成立</span><br><span class="line">X X X ... X O O O ... O</span><br></pre></td></tr></table></figure>如果有這樣類似的特點，我們可以利用「單調性」來做二分搜。下界跟上界分別為$0$和$(最大門牌號碼-最小門牌號碼)/2$，每次去找中間點並用$O(n)$的方法來檢查是否成立。若不成立，則令 下界=mid+1，否則令上界=mid。  </p><p><em>時間複雜度：$O(nlogn)$</em></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: 11516 - WiFi.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Sat Dec 30 19:33:04 2017</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> house[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> ap, n, mx;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> mid2 = mid * <span class="number">2</span>;</span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (house[j] &lt;= house[i] + mid2 &amp;&amp; j &lt; n)</span><br><span class="line">            j++;</span><br><span class="line">        count++;</span><br><span class="line">        i = j;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; ap)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;count);</span><br><span class="line">    <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ap, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, house + i), house[i] *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ap &gt;= n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0.0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(house, house + n);</span><br><span class="line">        mx = house[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> down, up;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        down = <span class="number">0</span>;</span><br><span class="line">        up = house[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (up - down &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mid = (down + up)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(mid))</span><br><span class="line">                up = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                down = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, up / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;大街上的居民開會決定要在他們居住的街上安裝無線網路，讓無線網路環境涵蓋所有住戶，請你幫忙選擇無線網路基地台(AP)的地點，他們希望訊號愈強愈好，但他們購買AP的預算有限，在有限的AP數量之下，使得在「所有房子與其最近的AP之間的距離」中最大值，愈小愈好。&lt;br&gt;
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="Binary Search" scheme="http://samuel21119.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Convert Physical OS to Virtual Machine</title>
    <link href="http://samuel21119.github.io/2019/02/24/Convert-Physical-OS-to-Virtual-Machine/"/>
    <id>http://samuel21119.github.io/2019/02/24/Convert-Physical-OS-to-Virtual-Machine/</id>
    <published>2019-02-24T14:05:49.000Z</published>
    <updated>2019-03-01T07:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下將以Arch Linux做示範。</p><p>如果以「migrate physical machine to virtualbox」之類的詞當作關鍵字去Google，會發現網路上的做法都是請你使用Virtual Box的指令來達成目的：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> VBoxManage internalcommands createrawvmdk -filename &lt;path-to-file&gt;.vmdk -rawdisk &lt;disk-location&gt; -partitions &lt;partitions-to-migrate&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>可是在我的電腦上，當我執行此指令時會發生悲劇：  </p><blockquote><p>VBoxManage: error: Cannot open the raw disk &#39;/dev/disk0&#39;: VERR_ACCESS_DENIED<br>VBoxManage: error: The raw disk vmdk file was not created</p></blockquote><p>詳細原因我不太清楚，網路上有人說是因為System Integrity Protection(macOS的系統保護機制)是啟動的關係，但是我就算關掉了還是沒有用。<br>後來我就到網路上查查看有沒有辦法把磁碟映像檔轉成VirtualBox的虛擬碟格式，發現可以用<code>VBoxManage convertfromraw</code>這個指令達成，所以我就想到了一個比較神奇的方法：  </p><p>首先，先把我要的磁碟分割區dd出來(root和efi分割區)：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> dd if=&lt;root-partition&gt; of=~/root.iso bs=2M</span><br><span class="line"><span class="meta">#</span> dd if=&lt;efi-partition&gt; of=~/efi.iso bs=2M</span><br></pre></td></tr></table></figure>這裡要注意的是dd出來的映像檔大小=分割區大小，所以如果本機磁碟空間不夠可以把這兩個映像檔塞到其他地方。  </p><p>接著我們要把磁碟映像檔轉成虛擬碟格式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> VBoxManage convertfromraw root.iso root.vdi</span><br><span class="line"><span class="meta">$</span> VBoxManage convertfromraw efi.iso efi.vdi</span><br></pre></td></tr></table></figure>前置作業到此為止</p><hr><h1 id="Import-root-partition"><a href="#Import-root-partition" class="headerlink" title="Import root partition"></a>Import root partition</h1><p>接下來進入了重頭戲。</p><p>開啟Virtual Box後建立一個虛擬機，作業系統選擇Linux，然後磁碟大小設定要比原本的那兩個分割區還大。<br>建立完虛擬機之後到設定裡面新增開機映像檔和剛剛建立的虛擬碟：</p><p><img src="1.png" alt=""><img src="2.png" alt=""> </p><p>然後開啟虛擬機，(這裡會使用BIOS Legacy方法開機，因為Virtual Box用UEFI開Arch Linux會黑屏)輸入<code>fdisk -l</code>查看裝載的磁碟編號，可以根據磁碟大小來判斷。以我的狀況來看，/dev/sda是剛建立的虛擬碟 /dev/sdb是原先的root.vdi /dev/sdc是efi.vdi。<br>利用<code>fdisk /dev/sda</code>來分割磁碟，產生一個空間為200MiB和剩下所有空間的分割區(類型為預設的Linux就好，不需要像UEFI那樣設定ef00)。  </p><p>格式化開機分割區：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> mkfs.ext2 /dev/sda1          #boot分割區</span><br></pre></td></tr></table></figure>把原先的root.vdi檔案複製到/dev/sda2。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> dd if=/dev/sdb of=/dev/sda2 bs=2M</span><br></pre></td></tr></table></figure>裝載磁碟：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> mount /dev/sda2 /mnt</span><br><span class="line"><span class="meta">#</span> mount /dev/sda1 /mnt/boot   #若無boot資料夾請建立一個</span><br></pre></td></tr></table></figure>重新產生fstab：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> genfstab /mnt -U &gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>root分割區移植到這裡結束。</p><hr><h1 id="Import-boot-partition"><a href="#Import-boot-partition" class="headerlink" title="Import boot partition"></a>Import boot partition</h1><p>先建立/mnt2資料夾，以便於裝載之前產生的efi.vdi<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> mkdir /mnt2</span><br><span class="line"><span class="meta">#</span> mount /dev/sdc /mn2</span><br></pre></td></tr></table></figure>把efi裡面系統kernel檔案複製出來<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> cd /mnt2</span><br><span class="line"><span class="meta">#</span> cp *linux* /mnt/boot</span><br><span class="line"><span class="meta">#</span> arch-chroot /mnt</span><br><span class="line"><span class="meta">#</span> mkinitcpio -p linux</span><br></pre></td></tr></table></figure>重新安裝BIOS Legacy版本grub<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> arch-chroot /mnt</span><br><span class="line"><span class="meta">#</span> grub install /dev/sda</span><br><span class="line"><span class="meta">#</span> grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>到這裡若系統都沒噴錯誤，就算移植整個系統完成了。</p><hr><h1 id="Export-VM-to-VMware-Optional"><a href="#Export-VM-to-VMware-Optional" class="headerlink" title="Export VM to VMware (Optional)"></a>Export VM to VMware (Optional)</h1><p>因為我習慣用VMware Fusion作為虛擬機軟體，而且Virtual Box效能上較不佳，所以我要把Virtual Box上的虛擬機匯出。<br>點擊Tab bar上面的File，選取Export Appliance以匯出。這裡要特別注意的是Open Virtualization Format一定要選1.0，2.0我測試過在後面的匯入會出錯。<img src="3.png" alt=""></p><p>匯出結束之後，開啟VMware Fusion，選Import an existing virtual machine，然後找到剛剛匯出的.ova檔案，接著按照指示完成匯入就大功告成了！</p><p>有圖有真相：<img src="4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下將以Arch Linux做示範。&lt;/p&gt;
&lt;p&gt;如果以「migrate physical machine to virtualbox」之類的詞當作關鍵字去Google，會發現網路上的做法都是請你使用Virtual Box的指令來達成目的：
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; VBoxManage internalcommands createrawvmdk -filename &amp;lt;path-to-file&amp;gt;.vmdk -rawdisk &amp;lt;disk-location&amp;gt; -partitions &amp;lt;partitions-to-migrate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教學" scheme="http://samuel21119.github.io/categories/%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="Linux" scheme="http://samuel21119.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>APCS. 2019/02/16</title>
    <link href="http://samuel21119.github.io/2019/02/19/APCS-2019-02-16/"/>
    <id>http://samuel21119.github.io/2019/02/19/APCS-2019-02-16/</id>
    <published>2019-02-19T03:44:23.000Z</published>
    <updated>2019-02-24T14:23:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>2019/02/19 APCS實作題詳解及範例程式<a id="more"></a></p><h1 id="pA"><a href="#pA" class="headerlink" title="pA"></a>pA</h1><p>無確切題目敘述及輸入格式。  </p><h1 id="pB"><a href="#pB" class="headerlink" title="pB"></a>pB</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>給定一個長度為$n(1&lt;n\le10^5)$的01字串，計算最長與最短的連續1長度。<br>接著有$k(1 \le k \le 2*10^4)$次操作，每次將一個0改成1。<br>對於每次操作，輸出當前最長與最短的連續1長度(包括一開始輸入的)。  </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>題目中有特別說到保證連續1的長度不超過$10^4$，所以可以用線性做法，不過這裡是考慮到當沒有這個限制時，應該怎麼做。  </p><p>使用Disjoint Set(並查集)紀錄連通塊(相鄰的1為同一塊)，接著用multiset紀錄每個連通塊的大小。<br>對於每次輸入，把該點的兩邊(注意要考慮到可能只有一邊是1的可能)的大小在multiset中去掉，然後用Disjoint Set合併，再將新的大小插入到multiset裡面。<br>輸出的時候輸出set中最大最小值即可。</p><p>時間複雜度：$O(n + klogn)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">disjoint_set</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> parent[maxn];</span><br><span class="line">    <span class="keyword">int</span> size[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == parent[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> parent[i] = find(parent[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pa = find(a);</span><br><span class="line">        <span class="keyword">int</span> pb = find(b);</span><br><span class="line">        s.erase(s.find(size[pa]));</span><br><span class="line">        s.erase(s.find(size[pb]));</span><br><span class="line">        size[pa] += size[pb];</span><br><span class="line">        parent[pb] = pa;</span><br><span class="line">        s.insert(size[pa]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ds;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ds.init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in[i];</span><br><span class="line">        <span class="keyword">if</span> (in[i])</span><br><span class="line">            s.insert(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i - <span class="number">1</span>] &amp;&amp; in[i]) &#123;</span><br><span class="line">            ds.connect(i - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *s.begin() &lt;&lt; <span class="string">' '</span> &lt;&lt; *s.rbegin() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">        ds.size[i] = <span class="number">1</span>;</span><br><span class="line">        s.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; in[i - <span class="number">1</span>])</span><br><span class="line">            ds.connect(i - <span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; in[i + <span class="number">1</span>])</span><br><span class="line">            ds.connect(i, i + <span class="number">1</span>);</span><br><span class="line">        in[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *s.begin() &lt;&lt; <span class="string">' '</span> &lt;&lt; *s.rbegin() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pC"><a href="#pC" class="headerlink" title="pC"></a>pC</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>給你三個數值函數f,g,h的定義，變數數目各為1,2,3，且保證均為一次函數。輸入一個三者的合成函數但所有括號與逗點都被空白取代，計算該合成函數的值。題目中提示可以用遞迴，並保證不必使用大數運算。</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>遞迴做下去。<br>由於我沒有f,g,h的係數，所以在程式中會標示為$f0, g0, g1, h0, h1, h2$代表各個係數。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f0, g[<span class="number">2</span>], h[<span class="number">3</span>];</span><br><span class="line"><span class="function">ll <span class="title">toll</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    ll re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;i : s) &#123;</span><br><span class="line">        re *= <span class="number">10</span>;</span><br><span class="line">        re += i - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">char</span> cmd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    ll re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">'f'</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[<span class="number">0</span>]))</span><br><span class="line">            re = f0 * toll(s);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            re = f0 * calc(s[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">'g'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[<span class="number">0</span>]))</span><br><span class="line">                re += g[i] * toll(s);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                re += g[i] * calc(s[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[<span class="number">0</span>]))</span><br><span class="line">                re += h[i] * toll(s);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                re += h[i] * calc(s[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 測試用係數</span></span><br><span class="line">    f0 = <span class="number">2</span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>, g[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">1</span>, h[<span class="number">1</span>] = <span class="number">3</span>, h[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// init();</span></span><br><span class="line">    <span class="keyword">char</span> cmd;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cmd;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; calc(cmd) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pD"><a href="#pD" class="headerlink" title="pD"></a>pD</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>給定$n(1&lt;n&lt;2*10^5)$，及長度為$n$的陣列<code>a</code>和<code>b</code>$(0 \le a[i], b[i] \le 10^7)$。<br>$S(i)=i-max(j)-1 使得 a[i]+b[i]&lt;a[j] 且 j&lt;i (若j不存在，則j=0)$。<br>求$\sum_{i=1}^n S(i)$為何。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>從前面做到後面，假設當前index為$i$，則可以刪掉一些在$i$之前「不可能為答案」的數字。<br>這樣講解有點抽象，從下面的圖片比較容易懂：<br><img src="1.png" alt="">考慮$a[1]\text{~}a[5]$，可以發現$a[2]和a[4]$不可能為答案，因為$a[5]$比這兩個數字都還大。<br>所以可以把灰色部分砍掉，維護一個「遞減陣列」。<br><img src="2.png" alt="">而有了這個遞減陣列，就可以利用$a[6]+b[6]$去二分搜，找出最大的j滿足條件。  </p><p>不過到這裡還沒完，假設$S(i)$算完了，那應該要想辦法把$a[i]$加入該陣列。對於一個現成的遞減陣列，要怎麼加入新的元素？<br>一直檢查該陣列的後面，如果小於$a[i]$，則pop掉，否則就把$a[i]$加到最後面即可。  </p><p>時間複雜度：$O(nlogn)$</p><p><strong>注意：因為upper_bound預設是用在「遞增陣列」，並非遞減。所以我這裡在<code>upper_bound</code>時使用<code>rbegin</code>和<code>rend</code>，是因為我是維護一個遞減數列，但是<code>upper_bound</code>只適用遞增數列，所以就用反向的iterator來處理。</strong>  </p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num, index;</span><br><span class="line">    node() &#123;&#125;</span><br><span class="line">    node (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        num = a, index = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num &lt; b.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; arr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = upper_bound(arr.rbegin(), arr.rend(), node(a[i] + b[i], <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (ptr == arr.rend())</span><br><span class="line">            ans += i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += i - ptr-&gt;index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!arr.empty() &amp;&amp; arr.back().num &lt; a[i])</span><br><span class="line">            arr.pop_back();</span><br><span class="line">        arr.push_back(&#123;a[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/02/19 APCS實作題詳解及範例程式
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="DFS" scheme="http://samuel21119.github.io/tags/DFS/"/>
    
      <category term="Disjoint set" scheme="http://samuel21119.github.io/tags/Disjoint-set/"/>
    
      <category term="Binary Search" scheme="http://samuel21119.github.io/tags/Binary-Search/"/>
    
      <category term="APCS" scheme="http://samuel21119.github.io/tags/APCS/"/>
    
  </entry>
  
  <entry>
    <title>UVa 1427. Parade</title>
    <link href="http://samuel21119.github.io/2018/12/11/UVa-1427-Parade/"/>
    <id>http://samuel21119.github.io/2018/12/11/UVa-1427-Parade/</id>
    <published>2018-12-11T11:12:08.000Z</published>
    <updated>2019-02-26T04:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一個城市有n+1個橫向路和m+1個縱向路，一個國王從最北邊的進入，然後沿某種路線從最南邊出去，每小段橫向路都有一個高興值，但國王不會在某條橫向路待超過k分鐘，問國王可以得到的最大的高興值是多少？<br><a id="more"></a></p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>輸入包含多筆測資，第一行為$n\ m\ k$三整數，若$n=m=k=0$則程式結束。<br>接下來有$n+1$行，代表從北到南的東西向道路。每行有$m$個數字，代表此道路m個區域從西到東的高興值。再來有$n+1$行，也代表從北到南的東西向道路。每行有$m$個數字，代表此道路m個區域從西到東的長度。</p><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>每筆測資輸出一行，輸出最大的高興值，答案保證小於$2^{32}$。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3 2</span><br><span class="line">7 8 1</span><br><span class="line">4 5 6</span><br><span class="line">1 2 3</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure>本測資示意圖如下：<img src="1.png" alt=""><br>UVa - <a href="https://uva.onlinejudge.org/external/14/1427.pdf" target="_blank" rel="noopener">1427</a>  </p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>這題很明顯的是DP。但是如果用一般的DP寫，時間複雜度是$O(nm^2)$，會導致TLE，所以需要用優化將其複雜度壓下一個維度。<br>由於這是我第一次寫有關單調隊列的題解，所以在推導過程中可能不會寫得很好。  </p><p>令$dp[i][j]$為第i行時j點的最大幸福度。則可以轉移式可以寫成如下：<br>$dp[i][j] = max(dp[i][j], dp[i-1][k]+\text{happy_sum}[k\text{~}j]) 且 \text{length_sum}[k\text{~}j] \le K$<br>為了方便計算，令<br>$happy[i]=從0\text{~}i的高興值總和$<br>$len[i]=從0\text{~}i道路長度總和$<br>則可以寫成：<br>$dp[i][j] = max(dp[i][j],\text{ }dp[i-1][k] + happy[j] - happy[k]) 且 len[j] - len[k] \le K$<br>移項得：<br>$(dp[i - 1][k] - happy[k]) + happy[j]$<br>很明顯可以看出可以利用deque，維護$(dp[i - 1][k] - happy[k])$的遞減佇列，並在當最前項$len[j] - len[k] &gt; K$時pop掉，以確保最前項在滿足條件下為最大值。  </p><p>以上推倒過程只有討論到「左到右」的，實際上還要考慮「右到左」的移動。<br><em>時間複雜度：$O(nm)$</em></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: 01427 - Parade.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Tue Dec 11 09:21:54 2018</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll dp[<span class="number">2</span>][<span class="number">10010</span>];</span><br><span class="line">ll happy[<span class="number">110</span>][<span class="number">10010</span>];</span><br><span class="line">ll len[<span class="number">110</span>][<span class="number">10010</span>], k;</span><br><span class="line"><span class="keyword">int</span> dq[<span class="number">10010</span>], l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &amp;&amp; (n || m || k)) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; happy[i][j];</span><br><span class="line">                happy[i][j] += happy[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; len[i][j];</span><br><span class="line">                len[i][j] += len[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = i &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> prev = !now;</span><br><span class="line">            l = r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l != r &amp;&amp; len[i][j] - len[i][dq[l]] &gt; k)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">while</span> (l != r &amp;&amp; dp[prev][j] - happy[i][j] &gt;= dp[prev][dq[r - <span class="number">1</span>]] - happy[i][dq[r - <span class="number">1</span>]])</span><br><span class="line">                    r--;</span><br><span class="line">                dq[r++] = j;</span><br><span class="line">                dp[now][j] = dp[prev][dq[l]] - happy[i][dq[l]] + happy[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            l = r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l != r &amp;&amp; len[i][dq[l]] - len[i][j] &gt; k)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">while</span> (l != r &amp;&amp; dp[prev][j] + happy[i][j] &gt;= dp[prev][dq[r - <span class="number">1</span>]] + happy[i][dq[r - <span class="number">1</span>]])</span><br><span class="line">                    r--;</span><br><span class="line">                dq[r++] = j;</span><br><span class="line">                dp[now][j] = max(dp[now][j], dp[prev][dq[l]] + happy[i][dq[l]] - happy[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">            ans = max(ans, dp[n &amp; <span class="number">1</span>][i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一個城市有n+1個橫向路和m+1個縱向路，一個國王從最北邊的進入，然後沿某種路線從最南邊出去，每小段橫向路都有一個高興值，但國王不會在某條橫向路待超過k分鐘，問國王可以得到的最大的高興值是多少？&lt;br&gt;
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="Dynamic Programming" scheme="http://samuel21119.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>107學年度 校內初選題目</title>
    <link href="http://samuel21119.github.io/2018/10/25/107%E5%AD%B8%E5%B9%B4%E5%BA%A6-%E6%A0%A1%E5%85%A7%E5%88%9D%E9%81%B8%E9%A1%8C%E7%9B%AE/"/>
    <id>http://samuel21119.github.io/2018/10/25/107學年度-校內初選題目/</id>
    <published>2018-10-25T10:04:43.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>前幾天是雄中資訊學科能力競賽初試，而下面是這次競賽的題目，其中有幾題是出自於UVa的。<a id="more"></a></p><h1 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>給你平面上3個點的座標，請你判斷這三點是否共線。</p><h2 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h2><p>輸入含有多筆測資，每筆測資一列，含有6個整數$(x_1 \; y_1 \; x_2 \; y_2 \; x_3 \; y_3)$。分別代表這三個點的x,y座標。每個整數的範圍均介於-10000~10000之間。</p><h2 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h2><p>每筆測資輸出一列。如果這三點共線，請輸出&quot;yes&quot;，否則輸出&quot;no&quot;。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 1 1 2 2</span><br><span class="line">1 2 3 5 -1 -1</span><br><span class="line">0 0 1 2 3 3</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">no</span><br></pre></td></tr></table></figure><hr><h1 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>這是一種2個人的遊戲。開始的時候有$n$個整數在一個陣列中，兩個玩家A和B輪流去取陣列中的整數。每次每個玩家能夠從陣列的左邊或右邊（但不能同時從左邊和右邊）拿任意個連續的整數（但至少要拿一個）。<br>當所有的整數都被拿完時遊戲即結束。每個玩家得到的分數就是他所拿的那些整數的和。<br>當然，2個玩家都想要贏對方多一些。假如這2個玩家都是「超完美（optimal）」玩家，並且每次遊戲開始時都由 A 先拿，請問當遊戲結束時 A 得到的分數跟 B 得到的分數差是多少？</p><h2 id="Input-Format-1"><a href="#Input-Format-1" class="headerlink" title="Input Format"></a>Input Format</h2><p>輸入含有多組測試資料。每組測試資料的第一列有一個整數$n \; (0 &lt; n \le 100)$ 代表陣列中整數的數目。接下來為$n$個陣列中的整數。當$n=0$時代表輸入結束。</p><h2 id="Output-Format-1"><a href="#Output-Format-1" class="headerlink" title="Output Format"></a>Output Format</h2><p>對每組測試資料輸出一列，當遊戲結束時 A 得到的分數跟 B 得到的分數差是多少？</p><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 -10 -20 7</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">3</span><br><span class="line">-10 -20 7</span><br><span class="line">10</span><br><span class="line">5 -10 -20 -40 30 -50 -100 2 -4 -7</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">10</span><br><span class="line">-3</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>UVa - <a href="https://uva.onlinejudge.org/external/108/10891.pdf" target="_blank" rel="noopener">10891</a>  </p><hr><h1 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>這是學二元一次方程式時的經典問題：<br>有一個籠子裡面有雞和兔。已知有$n$個頭，$m$隻腳。請問籠子裡有幾隻雞，幾隻兔？<br>請注意：這裡的雞和兔都是正常的。 </p><h2 id="Input-Format-2"><a href="#Input-Format-2" class="headerlink" title="Input Format"></a>Input Format</h2><p>輸入含有多筆測資。每筆測資一列，有2個整數$n,m$。$(1\le n,m &lt;1000)$</p><h2 id="Output-Format-2"><a href="#Output-Format-2" class="headerlink" title="Output Format"></a>Output Format</h2><p>每筆測資輸出一列：有幾隻雞，幾隻兔。如果沒有答案請輸出&quot;no answer&quot;</p><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 14</span><br><span class="line">5 15</span><br><span class="line">5 16</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">no answer</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><hr><h1 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>一個數被稱為「超級指數」，當它至少是2個不同的正整數的次方(&gt;1)時。<br>例如: 64是超級指數，因為 $64=8^2$，並且$64=4^3$<br>你的任務是找出所有小於$2^{64}$的所有超級指數。</p><h2 id="Input-Format-3"><a href="#Input-Format-3" class="headerlink" title="Input Format"></a>Input Format</h2><p>本題沒有輸入。 </p><h2 id="Output-Format-3"><a href="#Output-Format-3" class="headerlink" title="Output Format"></a>Output Format</h2><p>每個超級指數輸出一列，由小到大。前幾個數請見範例輸出。 </p><h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">16</span><br><span class="line">64</span><br><span class="line">81</span><br><span class="line">256</span><br><span class="line">512</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>使用<code>unsigned long long</code><br>共有67385個超級指數</p><hr><h1 id="Problem-E"><a href="#Problem-E" class="headerlink" title="Problem E"></a>Problem E</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>給你一個僅含有數字的字串，你的任務是在此字串中找出最大的質數。  </p><p>在本問題中，質數的範圍限定在 2~100000</p><h2 id="Input-Format-4"><a href="#Input-Format-4" class="headerlink" title="Input Format"></a>Input Format</h2><p>輸入含有多筆測資，每筆測資一列。<br>每筆測資含有一字串，僅含有數字且長度最大255<br>當輸入測資為0時，代表輸入結束，本筆測資不須輸出。</p><h2 id="Output-Format-4"><a href="#Output-Format-4" class="headerlink" title="Output Format"></a>Output Format</h2><p>每筆測資輸出字串中出現最大的質數。</p><h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11245</span><br><span class="line">91321150448</span><br><span class="line">1226406</span><br><span class="line">33</span><br><span class="line">22331</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">1321</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">331</span><br></pre></td></tr></table></figure><p>UVa - <a href="https://uva.onlinejudge.org/external/125/12542.pdf" target="_blank" rel="noopener">12542</a>  </p><hr><h1 id="Problem-F"><a href="#Problem-F" class="headerlink" title="Problem F"></a>Problem F</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>一個迴文(palindrome)是指一個字串從左到右和從又到左念起來都一樣。<br>例如: &quot;上海自來水來自海上&quot;，&quot;madam&quot;，&quot;qq&quot; 等都是迴文。<br>給你任一個字串，請你算出要經過多少次「交換」才能把它變成迴文。<br>在這裡「交換」是指將相鄰的2個字元對調。  </p><p>例如: 字串 &quot;mamad&quot; 可以經由3次交換，使之成為迴文 &quot;madam&quot;，過程如下:<br>把ad交換，字串變成 mamda<br>把md交換，字串變成 madma<br>把ma交換，字串變成 madam  </p><h2 id="Input-Format-5"><a href="#Input-Format-5" class="headerlink" title="Input Format"></a>Input Format</h2><p>輸入的第一列含有一個整數，代表以下有幾筆測資。<br>每筆測資一列，含有一字串，僅含小寫字元且長度最大100。</p><h2 id="Output-Format-5"><a href="#Output-Format-5" class="headerlink" title="Output Format"></a>Output Format</h2><p>每筆測資輸出一列，經過多少次「交換」才能把輸入字串變成迴文。如果不可能做到，請輸出&quot;Impossible&quot;。</p><h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">mamad</span><br><span class="line">asflkj</span><br><span class="line">aabb</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Impossible</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>UVa - <a href="https://uva.onlinejudge.org/external/107/10716.pdf" target="_blank" rel="noopener">10716</a>  </p><hr><h1 id="Problem-G"><a href="#Problem-G" class="headerlink" title="Problem G"></a>Problem G</h1><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>給你一個含有障礙物及1~9數字的方陣，你可以從任何一個不為障礙物的格子開始走，最後停在某格子。<br>每一步你可以走到上、下、左、右四個鄰居格子其中之一。但是你不可以走到有障礙物的格子，你也不可以走到一個格子超過1次。<br>當你結束時，根據你剛才走過的格子的順序，你會得到一個數字。  </p><p>請參考下圖：<img src="1.png" alt="">以這圖片為例，最大數字為791452384。</p><h2 id="Input-Format-6"><a href="#Input-Format-6" class="headerlink" title="Input Format"></a>Input Format</h2><p>輸入含有多筆測資。  </p><p>每筆測資的第一列，含有2個數字$R,C(2 \le R,C \le 15, R*C\le30)$，代表方陣的高度及長度。<br>接下來的$R$列，每列含有$C$個字元。僅含有#及1~9。#代表該格子為障礙物。方陣中至少會有一個格子為數字1~9。當$R=C=0$時，代表輸入結束。</p><h2 id="Output-Format-6"><a href="#Output-Format-6" class="headerlink" title="Output Format"></a>Output Format</h2><p>每筆測資輸出一列，輸出你可以走出來最大的數字。</p><h2 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 7</span><br><span class="line">##9784#</span><br><span class="line">##123##</span><br><span class="line">##45###</span><br><span class="line">2 5</span><br><span class="line">#3#12</span><br><span class="line">#####</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-6"><a href="#Sample-Output-6" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">791452384</span><br><span class="line">21</span><br></pre></td></tr></table></figure><p>UVa - <a href="https://uva.onlinejudge.org/external/118/11882.pdf" target="_blank" rel="noopener">11882</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前幾天是雄中資訊學科能力競賽初試，而下面是這次競賽的題目，其中有幾題是出自於UVa的。
    
    </summary>
    
      <category term="題目" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E7%9B%AE/"/>
    
    
      <category term="DFS" scheme="http://samuel21119.github.io/tags/DFS/"/>
    
      <category term="Dynamic Programming" scheme="http://samuel21119.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Math" scheme="http://samuel21119.github.io/tags/Math/"/>
    
      <category term="Greedy" scheme="http://samuel21119.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>UVa 838. Worm World</title>
    <link href="http://samuel21119.github.io/2018/10/09/UVa-838-Worm-World/"/>
    <id>http://samuel21119.github.io/2018/10/09/UVa-838-Worm-World/</id>
    <published>2018-10-09T14:38:59.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>給定一張n*n的圖，每個格子上面都有一個數字。<br>求在不碰到重複數字的情況下，最遠可以走多遠（只能上下左右移動）？<a id="more"></a></p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>輸入的第一列有一個整數代表以下有多少組測試資料。<br>每組測試資料的第一列，有一個整數$N(0 &lt; N \le 12)$，代表這方陣的邊長大小。接下來有$N$列，每列有$N$個整數（均介於 0 到 1000 之間）代表方陣中的數字。<br>第一列與第一組測試資料以及各組測試資料間均有一空白列</p><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>對於每一筆測資請輸出一列，輸出最遠距離為多少。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 4</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/8/838.pdf" target="_blank" rel="noopener">838</a>  </p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>從uHunt上面看到這題的解題統計，可以發現TLE占非常多數。<br><img src="1.png" alt="">所以這題的難度就是在於，如何降低程式執行時間？<br>首先先分析一下這題的做法，很明顯的可以看出可以用DFS來解。</p><blockquote><p>對於每一層遞迴，朝上下左右四個方向去做遞迴，若遇到重複出現的數字就跳出。</p></blockquote><p>然後我們可以再做一下優化：  </p><blockquote><p>假設此圖出現$k$個不同的數字，則最長路徑距離應為$k$，所以如果$遞迴深度 \ge k$，則可以$return$。</p></blockquote><p>但是就算做了上述的優化，還是會TLE。結果後來我發現，dfs的順序很重要，「上左下右」跟「上下左右」等其他順序執行出來的時間差很多，到目前為止我還是不能證明出來為何會這樣，但是只要照著「上左下右」的順序去寫就可以輕鬆拿到AC了！  </p><p>程式執行結果如下圖：<img src="2.png" alt=""></p><p>網路上有人這題使用A*+Heap的作法，但是程式非常冗長且複雜，而且執行時間比我寫的還久一點，所以這裡就不說明了。  </p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: 00838 - Worm World.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Tue Oct  2 17:06:29 2018</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> in[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//up left down right</span></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> ans, cnt, n, t, c, ni, nj, steps;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans == cnt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit[in[i][j]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        ni = i + d[<span class="number">0</span>][k];</span><br><span class="line">        nj = j + d[<span class="number">1</span>][k];</span><br><span class="line">        <span class="keyword">if</span> (nj &lt; <span class="number">0</span> || ni &lt; <span class="number">0</span> || nj == n || ni == n)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visit[in[ni][nj]])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        steps++;</span><br><span class="line">        dfs(ni, nj);</span><br><span class="line">        steps--;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(ans, steps);</span><br><span class="line">    visit[in[i][j]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; c; t &lt; c; ) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        cnt = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; in[i][j];</span><br><span class="line">                <span class="keyword">if</span> (!visit[in[i][j]])</span><br><span class="line">                    visit[in[i][j]] = <span class="number">1</span>, cnt++;</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                steps = <span class="number">1</span>;</span><br><span class="line">                dfs(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">if</span> (++t &lt; c)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;給定一張n*n的圖，每個格子上面都有一個數字。&lt;br&gt;求在不碰到重複數字的情況下，最遠可以走多遠（只能上下左右移動）？
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="DFS" scheme="http://samuel21119.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>UVa 10600. ACM contest and Blackout</title>
    <link href="http://samuel21119.github.io/2018/09/22/UVa-10600-ACM-contest-and-Blackout/"/>
    <id>http://samuel21119.github.io/2018/09/22/UVa-10600-ACM-contest-and-Blackout/</id>
    <published>2018-09-22T04:24:55.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>給定一張無向圖，請輸出最小生成樹和次小生成樹的大小。<a id="more"></a></p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>第一行會有t，代表有t個測資$(1 &lt; t &lt; 15)$。接下來每個測資會有N M，代表n個點以及m條邊(3 &lt; N &lt; 100)。然後會有M行，$a_i b_i v_i$代表第$i$條邊的兩端點以及權重v。</p><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>每組測試資料輸出最小生成樹和次小生成樹大小，中間用一個空格格開。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5 8</span><br><span class="line">1 3 75</span><br><span class="line">3 4 51</span><br><span class="line">2 4 19</span><br><span class="line">3 2 95</span><br><span class="line">2 5 42</span><br><span class="line">5 4 31</span><br><span class="line">1 2 9</span><br><span class="line">3 5 66</span><br><span class="line">9 14</span><br><span class="line">1 2 4</span><br><span class="line">1 8 8</span><br><span class="line">2 8 11</span><br><span class="line">3 2 8</span><br><span class="line">8 9 7</span><br><span class="line">8 7 1</span><br><span class="line">7 9 6</span><br><span class="line">9 3 2</span><br><span class="line">3 4 7</span><br><span class="line">3 6 4</span><br><span class="line">7 6 2</span><br><span class="line">4 6 14</span><br><span class="line">4 5 9</span><br><span class="line">5 6 10</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110 121</span><br><span class="line">37 37</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/106/10600.pdf" target="_blank" rel="noopener">10600</a>  </p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>這題搞了兩天才寫出來，後來是發現原來UVa的毒瘤輸入N會=100，害我一直WA。<br><strong>注意：題目的n範圍應修正為$3 &lt; N \le 100$</strong><br>回歸正題，求次小生成樹的方法是：<br>對於已經求好的MST，枚舉每一條未使用的邊，並且判斷加入此邊之後的最小升成樹大小(枚舉的邊必須使用到)。<br>也代表假設加入的邊為a, b、長度v，則$原先MST大小-(a到b之間的最大邊長度)+v=此查詢的MST$，然後對每一次查詢的MST求min即可。  </p><p>所以重點是要怎麼對每一次查詢求兩點之間的最大邊長，有以下幾種方法可求：</p><ol><li>暴力：<em>$O(N^2)$</em>預處理，<em>$O(1)$</em>查詢</li><li>LCA倍增法：<em>$O(NlogN)$</em>預處理，<em>$O(logN)$</em>查詢</li><li>樹鏈剖分：<em>$O(N)$</em>預處理，<em>$O(log^2N)$</em>查詢</li></ol><p>這裡我選擇用第二種方法，因為第一種在$n=10^5$的題目上就行不通，而樹鏈剖分常數大且查詢比較慢，實作上也比較難理解。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: 10600 - ACM contest and Blackout.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Thu Sep 20 12:17:39 2018</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">l</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> l &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">    l() &#123;&#125;</span><br><span class="line">    l(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> v) : a(a), b(b), val(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;l&gt; line;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; mst[maxn];</span><br><span class="line"><span class="keyword">int</span> parent[maxn], ans1, ans2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> logn;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp[maxn], maxdp[maxn];</span><br><span class="line"><span class="keyword">int</span> deep[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == parent[i])</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> parent[i] = find(parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        mst[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : line) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = find(i.a);</span><br><span class="line">        <span class="keyword">int</span> b = find(i.b);</span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        parent[b] = a;</span><br><span class="line">        mst[i.a].emplace_back(make_pair(i.b, i.val));</span><br><span class="line">        mst[i.b].emplace_back(make_pair(i.a, i.val));</span><br><span class="line">        ans1 += i.val;</span><br><span class="line">        i.val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (++cnt == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> parent, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    dp[now].resize(logn);</span><br><span class="line">    maxdp[now].resize(logn);</span><br><span class="line">    dp[now][<span class="number">0</span>] = parent;</span><br><span class="line">    maxdp[now][<span class="number">0</span>] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; logn; i++) &#123;</span><br><span class="line">        dp[now][i + <span class="number">1</span>] = dp[dp[now][i]][i];</span><br><span class="line">        maxdp[now][i + <span class="number">1</span>] = max(maxdp[now][i], maxdp[dp[now][i]][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : mst[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.first == parent)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        deep[i.first] = deep[now] + <span class="number">1</span>;</span><br><span class="line">        dfs(i.first, now, i.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &lt; deep[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deep[a] - deep[b], k = <span class="number">0</span>; i; i &gt;&gt;= <span class="number">1</span>, k++)</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            mx = max(mx, maxdp[a][k]);</span><br><span class="line">            a = dp[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = logn - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[a][i] != dp[b][i]) &#123;</span><br><span class="line">            mx = max(mx, max(maxdp[a][i], maxdp[b][i]));</span><br><span class="line">            a = dp[a][i];</span><br><span class="line">            b = dp[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(max(mx, maxdp[a][<span class="number">0</span>]), maxdp[b][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        line.resize(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; v;</span><br><span class="line">            a--; b--;</span><br><span class="line">            line[i] = &#123;a, b, v&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(line.begin(), line.end());</span><br><span class="line">        ans1 = <span class="number">0</span>;</span><br><span class="line">        ans2 = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        MST();</span><br><span class="line">        logn = log2(n) + <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : line) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i.val)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ans2 = min(ans2, i.val - LCA(i.a, i.b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="string">' '</span> &lt;&lt; ans1 + ans2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;給定一張無向圖，請輸出最小生成樹和次小生成樹的大小。
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="Tree" scheme="http://samuel21119.github.io/tags/Tree/"/>
    
      <category term="LCA" scheme="http://samuel21119.github.io/tags/LCA/"/>
    
      <category term="MST" scheme="http://samuel21119.github.io/tags/MST/"/>
    
  </entry>
  
  <entry>
    <title>UVa 165. Stamps</title>
    <link href="http://samuel21119.github.io/2018/09/15/UVa-165-Stamps/"/>
    <id>http://samuel21119.github.io/2018/09/15/UVa-165-Stamps/</id>
    <published>2018-09-15T13:28:30.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>每張信封上面最多可以貼上h張郵票，請設計k種面額，並求出能組成的連續面額最大值。<br>例如當$h=3, k=2$，1和3元的面額最多可以連續從1組到7。<br><a id="more"></a></p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>輸入包含多筆測資<br>每組測資會給予$h$和$k$<br>當$h=k=0$時結束程式  </p><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>每組測試資料輸出一列，輸出k種面額，以及最大連續面額為多少。  </p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  3 -&gt;  7</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/1/165.pdf" target="_blank" rel="noopener">165</a>  </p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，可以先確認一定會有面額為1的郵票，因為畢竟是要組成連續的數字。<br>接著使用DFS求出第$2~k$的郵票面額。<br>在我的程式裡面，<code>use[i]</code>表第$i$郵票的值；<code>maxsum[i]</code>陣列表示第i郵票及之前所有郵票可以組到的連續面額最大值。<br>對於每一次遞迴，可確定當前第$i$個郵票枚舉的面額範圍必為<code>use[i - 1] + 1</code> ~ <code>maxsum[i - 1] + 1</code>  </p><p>優化筆記：</p><ol><li>在求maxsum[]的時候，有一種做法是DFS暴力搜尋所有組合，這裡使用DP+Bitwise的方法優化。  </li><li>在將<code>use</code>複製到<code>ans</code>時，用memcpy取代for，可以降低執行時間，優化結果如下圖。  </li></ol><p><img src="1.png" alt=""></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: 00165 - Stamps.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Fri Feb 16 16:53:08 2018</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> h, k, mx;</span><br><span class="line"><span class="keyword">int</span> use[<span class="number">10</span>], maxsum[<span class="number">10</span>], ans[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> check[<span class="number">75</span>];</span><br><span class="line"><span class="keyword">int</span> bit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxsum[k - <span class="number">1</span>] &gt; mx) &#123;</span><br><span class="line">            mx = maxsum[k - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(ans, use, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = use[index - <span class="number">1</span>] + <span class="number">1</span>; i &lt;= maxsum[index - <span class="number">1</span>] + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line">        check[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        use[index] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= index; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = use[j]; k &lt; <span class="number">75</span>; k++)</span><br><span class="line">                check[k] |= check[k - use[j]] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (check[++j] &amp; bit);</span><br><span class="line">        maxsum[index] = j - <span class="number">1</span>;</span><br><span class="line">        search(index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;h, &amp;k) &amp;&amp; h + k) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(use, <span class="number">0</span>, <span class="keyword">sizeof</span>(use));</span><br><span class="line">        ans[<span class="number">0</span>] = use[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        maxsum[<span class="number">0</span>] = h;</span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">            bit |= bit &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        search(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" -&gt;%3d\n"</span>, mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;每張信封上面最多可以貼上h張郵票，請設計k種面額，並求出能組成的連續面額最大值。&lt;br&gt;例如當$h=3, k=2$，1和3元的面額最多可以連續從1組到7。&lt;br&gt;
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="DFS" scheme="http://samuel21119.github.io/tags/DFS/"/>
    
      <category term="Dynamic Programming" scheme="http://samuel21119.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>UVa 10917. Walk Through the Forest</title>
    <link href="http://samuel21119.github.io/2018/09/09/UVa-10917-Walk-Through-the-Forest/"/>
    <id>http://samuel21119.github.io/2018/09/09/UVa-10917-Walk-Through-the-Forest/</id>
    <published>2018-09-09T02:23:31.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Jimmy的辦公室在森林的一邊，而他的家在森林的另一邊。<br>Jimmy想要每天都走不同的路徑回家。但是他也不想要回家太晚，所以他總是選擇一條可以朝他家「前進」的路徑來走。所謂「前進」指的是他會選擇從A點走到B點如果B點存在一條到他家的路徑長度比A點到他家任一路徑的長度都來的短的話。請你算出Jimmy共有多少種不同的路徑可以走。<br><a id="more"></a></p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>輸入包含多筆測資<br>第一列包含兩個整數N$(1 &lt; N \le 1000)$和M，N代表有多少點(編號從1到N，請注意：編號<strong>1</strong>的點為Jimmy的辦公室，編號<strong>2</strong>的點為Jimmy的家)，M代表共有多少個連接2個點的邊。接下來的M列每列有3個整數 a, b, d。a,b為點的編號，d 為連接 a,b 的路徑長（在這裡 a,b 不會相同，$1 \le d \le 1000000$）。路徑是雙向的，且任2點之間僅有一條路徑連接。  </p><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>每組測試資料輸出一列，Jimmy共有多少種不同的路徑可以走。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 3 2</span><br><span class="line">1 4 2</span><br><span class="line">3 4 3</span><br><span class="line">1 5 12</span><br><span class="line">4 2 34</span><br><span class="line">5 2 24</span><br><span class="line">7 8</span><br><span class="line">1 3 1</span><br><span class="line">1 4 1</span><br><span class="line">3 7 1</span><br><span class="line">7 4 1</span><br><span class="line">7 5 1</span><br><span class="line">6 7 1</span><br><span class="line">5 2 1</span><br><span class="line">6 2 1</span><br><span class="line">5 7</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/109/10917.pdf" target="_blank" rel="noopener">10917</a><br>翻譯來源：<a href="http://luckycat.kshs.kh.edu.tw/homework/q10917.htm" target="_blank" rel="noopener">Luckycat</a></p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>這題還滿有趣的，因為朝家「前進」，所以需要重新構圖。<br>由於每步都會朝他家「前進」，所以可以先想到對於點<strong>2</strong>去做單源最短路徑(Dijkstra)。<br>然後再重新構圖，且這邊要注意是有向邊。<br><strong>注意：以下Code點的編號是從0到N-1</strong></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: 10917 - A Walk Through the Forest.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Tue Sep  4 12:04:50 2018</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; link[<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rebuild[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> distant[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, index;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    node() &#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> d, <span class="keyword">int</span> i) : dis(d), index(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[now] == <span class="number">-1</span>) &#123;</span><br><span class="line">        dp[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : rebuild[now])</span><br><span class="line">            dp[now] += dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    pq.push(node(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    distant[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        cur = pq.top().index;</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (visit[cur])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        visit[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : link[cur]) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = i.first;</span><br><span class="line">            <span class="keyword">int</span> dis = i.second;</span><br><span class="line">            <span class="keyword">if</span> (distant[next] &gt; distant[cur] + dis) &#123;</span><br><span class="line">                distant[next] = distant[cur] + dis;</span><br><span class="line">                pq.push(node(distant[next], next));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> next, dis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        rebuild[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : link[i])</span><br><span class="line">            <span class="keyword">if</span> (distant[i] &gt; distant[j.first])</span><br><span class="line">                rebuild[i].emplace_back(j.first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(link, <span class="number">0</span>, <span class="keyword">sizeof</span>(link));</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">            distant[i] = inf;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            link[--a].push_back(&#123;--b, c&#125;);</span><br><span class="line">            link[b].push_back(&#123;a, c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra();</span><br><span class="line">        build();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dfs(<span class="number">0</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;Jimmy的辦公室在森林的一邊，而他的家在森林的另一邊。&lt;br&gt;Jimmy想要每天都走不同的路徑回家。但是他也不想要回家太晚，所以他總是選擇一條可以朝他家「前進」的路徑來走。所謂「前進」指的是他會選擇從A點走到B點如果B點存在一條到他家的路徑長度比A點到他家任一路徑的長度都來的短的話。請你算出Jimmy共有多少種不同的路徑可以走。&lt;br&gt;
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="DFS" scheme="http://samuel21119.github.io/tags/DFS/"/>
    
      <category term="Dynamic Programming" scheme="http://samuel21119.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Dijkstra" scheme="http://samuel21119.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>UVa 12538. Version Controlled IDE</title>
    <link href="http://samuel21119.github.io/2018/08/26/UVa-12538-Version-Controlled-IDE/"/>
    <id>http://samuel21119.github.io/2018/08/26/UVa-12538-Version-Controlled-IDE/</id>
    <published>2018-08-26T13:59:15.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>題目有三種操作：<br>1 p s: 在當前字串位置p後插入s字串。<br>2 p c: 將當前字串位置p後面連續c個字符移除。<br>3 v p c: 在版本號v的字串中，在位置p之後印出c個字元。  </p><p>由於怕離線處理，因此輸入的數值會進行加密：<br>每個數字會增加數值d，其d為當前打印字符<code>c</code>的個數。<a id="more"></a></p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 0 abcdefgh</span><br><span class="line">2 4 3</span><br><span class="line">3 1 2 5</span><br><span class="line">3 3 3 4</span><br><span class="line">1 4 xy</span><br><span class="line">3 5 4 6</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bcdef</span><br><span class="line">bcg</span><br><span class="line">bxyc</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/125/12538.pdf" target="_blank" rel="noopener">12538</a>  </p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>這題需要利用可持久化Treap來解。<br>持久化Treap與一般的Treap在寫法上來看其實差異點只有兩點：</p><ol><li>因為複製點的時候會連Priority值一起複製，導致之後Treap會接近鏈狀，所以需要將Treap改成「隨機二叉樹」，在merge的時候，將Priority值比較的部分改成亂數（第51行）。  </li><li>持久化的概念在於Copy-on-write，所以在split或是merge的時候均需要複製（<code>new node()</code>）一遍。  </li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: 12538 - Version Controlled IDE.cpp</span></span><br><span class="line"><span class="comment"> &gt; Author: Samuel</span></span><br><span class="line"><span class="comment"> &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment"> &gt; Created Time: Sun Aug 26 00:22:34 2018</span></span><br><span class="line"><span class="comment"> *************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, cmd, version;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    node *l, *r;</span><br><span class="line">    node(<span class="keyword">char</span> _c):c(_c) &#123;</span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">        l = r = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="number">1</span> + (l ? l-&gt;s : <span class="number">0</span>) + (r ? r-&gt;s : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l)</span><br><span class="line">            l-&gt;print();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'c'</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">if</span> (r)</span><br><span class="line">            r-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(node *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o ? o-&gt;s : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(node *&amp;o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    o = <span class="keyword">new</span> node(s[m]);</span><br><span class="line">    build(o-&gt;l, l, m - <span class="number">1</span>, s);</span><br><span class="line">    build(o-&gt;r, m + <span class="number">1</span>, r, s);</span><br><span class="line">    o-&gt;up();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">merge</span><span class="params">(node *a, node *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a || !b)</span><br><span class="line">        <span class="keyword">return</span> a ? (<span class="keyword">new</span> node(*a)) : (<span class="keyword">new</span> node(*b));</span><br><span class="line">    <span class="keyword">if</span> (rand() % (a-&gt;s + b-&gt;s) &lt; a-&gt;s) &#123;</span><br><span class="line">        a = <span class="keyword">new</span> node(*a);</span><br><span class="line">        a-&gt;r = merge(a-&gt;r, b);</span><br><span class="line">        a-&gt;up();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    b = <span class="keyword">new</span> node(*b);</span><br><span class="line">    b-&gt;l = merge(a, b-&gt;l);</span><br><span class="line">    b-&gt;up();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(node *o, node *&amp;a, node *&amp;b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!o)</span><br><span class="line">        a = b = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        a = <span class="literal">nullptr</span>;</span><br><span class="line">        b = <span class="keyword">new</span> node(*o);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= size(o-&gt;l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a = <span class="keyword">new</span> node(*o);</span><br><span class="line">            split(o-&gt;r, a-&gt;r, b, k - size(o-&gt;l) - <span class="number">1</span>);</span><br><span class="line">            a-&gt;up();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            b = <span class="keyword">new</span> node(*o);</span><br><span class="line">            split(o-&gt;l, a, b-&gt;l, k);</span><br><span class="line">            b-&gt;up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    node *a, *b, *c;</span><br><span class="line">    split(root[version], a, c, x);</span><br><span class="line">    build(b, <span class="number">0</span>, s.length() - <span class="number">1</span>, s);</span><br><span class="line">    root[++version] = merge(a, merge(b, c));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    node *a, *b, *b2, *c;</span><br><span class="line">    split(root[version], a, b, x - <span class="number">1</span>);</span><br><span class="line">    split(b, b2, c, k);</span><br><span class="line">    root[++version] = merge(a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    node *a, *b, *b2, *c;</span><br><span class="line">    split(root[v], a, b, s - <span class="number">1</span>);</span><br><span class="line">    split(b, b2, c, e);</span><br><span class="line">    b2-&gt;print();</span><br><span class="line">    <span class="comment">//root[v] = merge(a, merge(b2, c));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cmd;</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; s;</span><br><span class="line">            insert(a - cnt, s);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            erase(a - cnt, b - cnt);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            print(a - cnt, b - cnt, c - cnt);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;題目有三種操作：&lt;br&gt;1 p s: 在當前字串位置p後插入s字串。&lt;br&gt;2 p c: 將當前字串位置p後面連續c個字符移除。&lt;br&gt;3 v p c: 在版本號v的字串中，在位置p之後印出c個字元。  &lt;/p&gt;
&lt;p&gt;由於怕離線處理，因此輸入的數值會進行加密：&lt;br&gt;每個數字會增加數值d，其d為當前打印字符&lt;code&gt;c&lt;/code&gt;的個數。
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="Treap" scheme="http://samuel21119.github.io/tags/Treap/"/>
    
      <category term="Tree" scheme="http://samuel21119.github.io/tags/Tree/"/>
    
      <category term="Persistence" scheme="http://samuel21119.github.io/tags/Persistence/"/>
    
  </entry>
  
  <entry>
    <title>Template. Fibonacci Matrix</title>
    <link href="http://samuel21119.github.io/2018/08/23/Template-Fibonacci-Matrix/"/>
    <id>http://samuel21119.github.io/2018/08/23/Template-Fibonacci-Matrix/</id>
    <published>2018-08-23T12:41:04.000Z</published>
    <updated>2019-02-10T15:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>$2 \times 2$矩陣表示費氏數列的方法如下  </p><a id="more"></a><p>$\begin{bmatrix}    x_2 &amp; x_1 \\    1 &amp; 0 \\\end{bmatrix} ^ n=\begin{bmatrix}    F_{n+1} &amp; F_n \\    F_n &amp; F_{n-1} \\\end{bmatrix}$  </p><p>搭配快速冪的算法可以將<em>$O(N)$</em>的複雜度降低到<em>$O(log N)$</em>。  </p><p>程式使用方法：<br><code>calc(n, a1, a2, x1, x2)</code><br>表第一項為<code>a1</code>，第二項為<code>a2</code>；<code>n</code>代表要求的第n項。<br>且$a_n = x_1 \times a_{n-2} + x_2 \times a_{n-1}$。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        Matrix re;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                re.c[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                    re.c[i][j] += c[i][k] * rhs.c[k][j];</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123;</span><br><span class="line">    Matrix tra;</span><br><span class="line">    tra.c[<span class="number">0</span>][<span class="number">0</span>] = x2; tra.c[<span class="number">0</span>][<span class="number">1</span>] = x1;</span><br><span class="line">    tra.c[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;  tra.c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Matrix re;</span><br><span class="line">    re.c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; re.c[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    re.c[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; re.c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; j; j &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &amp; <span class="number">1</span>)</span><br><span class="line">            re = re * tra;</span><br><span class="line">        tra = tra * tra;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123;</span><br><span class="line">    Matrix a = Pow(n - <span class="number">1</span>, x1, x2);</span><br><span class="line">    <span class="keyword">return</span> a.c[<span class="number">1</span>][<span class="number">0</span>] * a2 + a.c[<span class="number">1</span>][<span class="number">1</span>] * a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$2 \times 2$矩陣表示費氏數列的方法如下  &lt;/p&gt;
    
    </summary>
    
      <category term="模板" scheme="http://samuel21119.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Matrix" scheme="http://samuel21119.github.io/tags/Matrix/"/>
    
      <category term="Fibonacci" scheme="http://samuel21119.github.io/tags/Fibonacci/"/>
    
  </entry>
  
  <entry>
    <title>UVa 11456. Trainsorting</title>
    <link href="http://samuel21119.github.io/2018/08/21/UVa-11456-Trainsorting/"/>
    <id>http://samuel21119.github.io/2018/08/21/UVa-11456-Trainsorting/</id>
    <published>2018-08-21T09:54:50.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Erin是一個開火車工程師。他喜歡把車廂按照其重量來安排，重的車廂排在前端。<br>不幸的是，把車廂排序並不是一件容易的事。你只能將一節車廂加在一列火車的前端或後端。<br>各個車廂來到火車站的順序及其重量是已經知道的。當每節車廂來到的時候，Erin可以把它加到火車的兩端，或者不加進去。最後，火車的總車廂數是越長越好，不過要記得車廂得按照重量大小排列。<br>給你按照出現順序各車廂的重量，Erin最長可安排車廂的長度是多少？<a id="more"></a></p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>輸入的第一列有一個整數表示測試資料的組數。<br>每組資料的第一列會有1個整數$n$ ,$(0 \le n \le 2000)$，代表車廂的數目。接下來$n$列整數，每列有一個大於等於0的整數，代表各車廂的重量。<br>請注意：所有車廂的重量都不一樣。請參考 Sample Input。</p><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>對每組測試資料，Erin最長可安排車廂的長度是多少。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/114/11456.pdf" target="_blank" rel="noopener">11456</a><br>翻譯來源：<a href="http://luckycat.kshs.kh.edu.tw/homework/q11456.htm" target="_blank" rel="noopener">Luckycat</a></p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>因為有選取或不選取，可以考慮到使用DP的方法解。<br>令$up[i]\ down[i]$代表重量 大於/小於 第$i$車廂的最大車廂數。<br>接著跑迴圈每次取$max(ans, up[i] + down[i]-1)$就可以得到答案了。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: 11456 - Trainsorting.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Sat May 19 14:10:47 2018</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> up[<span class="number">2002</span>], down[<span class="number">2002</span>];</span><br><span class="line"><span class="keyword">int</span> input[<span class="number">2003</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> c, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="keyword">while</span>(c--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; input[i];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) up[i] = down[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (input[j] &lt; input[i])</span><br><span class="line">                    up[i] = max(up[i], up[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    down[i] = max(down[i], down[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, up[i] + down[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;Erin是一個開火車工程師。他喜歡把車廂按照其重量來安排，重的車廂排在前端。&lt;br&gt;不幸的是，把車廂排序並不是一件容易的事。你只能將一節車廂加在一列火車的前端或後端。&lt;br&gt;各個車廂來到火車站的順序及其重量是已經知道的。當每節車廂來到的時候，Erin可以把它加到火車的兩端，或者不加進去。最後，火車的總車廂數是越長越好，不過要記得車廂得按照重量大小排列。&lt;br&gt;給你按照出現順序各車廂的重量，Erin最長可安排車廂的長度是多少？
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="Dynamic Programming" scheme="http://samuel21119.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Template. Persistent Segment Tree</title>
    <link href="http://samuel21119.github.io/2018/08/20/Template-Persistent-Segment-Tree/"/>
    <id>http://samuel21119.github.io/2018/08/20/Template-Persistent-Segment-Tree/</id>
    <published>2018-08-20T15:10:48.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>可持久化線段樹適用於查詢不同版本的線段樹，其運作方式非常簡單，就是將要更改的點先複製一遍，未更改的點則不動。而且每新增一個節點，就建立一個新的root，所以我們就可以透過不同的root來讀取不同版本的值。<br><a id="more"></a>如下圖：<br><img src="1.png" alt="" title="區間和線段樹"><br>以下為區間和的持久化線段樹，同時也為<a href="https://zerojudge.tw/ShowProblem?problemid=a331" target="_blank" rel="noopener">Zero Judge a331</a>的AC Code。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    node *l, *r;</span><br><span class="line">    node()&#123;l = r = <span class="literal">nullptr</span>;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> n) : sum(n)&#123;l = r = <span class="literal">nullptr</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l)</span><br><span class="line">            sum += l-&gt;sum;</span><br><span class="line">        <span class="keyword">if</span> (r)</span><br><span class="line">            sum += r-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*tree[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    node *o = <span class="keyword">new</span> node(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    o-&gt;l = build(l, m);</span><br><span class="line">    o-&gt;r = build(m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">insert</span><span class="params">(node *o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; x || x &gt; r)</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    o = <span class="keyword">new</span> node(*o);</span><br><span class="line">    <span class="keyword">if</span> (l == r &amp;&amp; r == x) &#123;</span><br><span class="line">        o-&gt;sum = num;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    o-&gt;l = insert(o-&gt;l, l, m, x, num);</span><br><span class="line">    o-&gt;r = insert(o-&gt;r, m + <span class="number">1</span>, r, x, num);</span><br><span class="line">    o-&gt;up();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(node *f, node *b, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nxt = b-&gt;l-&gt;sum - f-&gt;l-&gt;sum;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= nxt)</span><br><span class="line">        <span class="keyword">return</span> find(f-&gt;l, b-&gt;l, l, m, k);</span><br><span class="line">    <span class="keyword">return</span> find(f-&gt;r, b-&gt;r, m + <span class="number">1</span>, r, k - nxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; in[i];</span><br><span class="line">            v.emplace_back(in[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        v.resize(unique(v.begin(), v.end()) - v.begin());</span><br><span class="line">        tree[<span class="number">0</span>] = build(<span class="number">0</span>, v.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            tree[i] = insert(tree[i - <span class="number">1</span>], <span class="number">0</span>, v.size(), lower_bound(v.begin(), v.end(), in[i]) - v.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[find(tree[a - <span class="number">1</span>], tree[b], <span class="number">0</span>, v.size(), c)] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可持久化線段樹適用於查詢不同版本的線段樹，其運作方式非常簡單，就是將要更改的點先複製一遍，未更改的點則不動。而且每新增一個節點，就建立一個新的root，所以我們就可以透過不同的root來讀取不同版本的值。&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://samuel21119.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Segment Tree" scheme="http://samuel21119.github.io/tags/Segment-Tree/"/>
    
      <category term="Tree" scheme="http://samuel21119.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>UVa 1479. Graph and Queries</title>
    <link href="http://samuel21119.github.io/2018/08/18/UVa-1479-Graph-and-Queries/"/>
    <id>http://samuel21119.github.io/2018/08/18/UVa-1479-Graph-and-Queries/</id>
    <published>2018-08-17T16:39:05.000Z</published>
    <updated>2019-02-10T15:15:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>給定一張無向圖，有三種操作：</p><ol><li>D x   ：刪除第x條邊</li><li>Q x y ：查詢x所在集合裡面第y大的數字，若查詢失敗，則此次查詢的結果為0</li><li>C x y ：將第x點的值改成y</li></ol><p>最後輸出所有查詢的平均值。<br><a id="more"></a>詳細內容請參照<a href="https://uva.onlinejudge.org/external/14/1479.pdf" target="_blank" rel="noopener">UVa 1479</a></p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">D 3</span><br><span class="line">Q 1 2</span><br><span class="line">Q 2 1</span><br><span class="line">D 2</span><br><span class="line">Q 3 2</span><br><span class="line">C 1 50</span><br><span class="line">Q 1 1</span><br><span class="line">E</span><br><span class="line"></span><br><span class="line">3 3</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">20</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">Q 1 1</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">E</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 25.000000</span><br><span class="line">Case 2: 16.666667</span><br></pre></td></tr></table></figure>UVa - <a href="https://uva.onlinejudge.org/external/14/1479.pdf" target="_blank" rel="noopener">1479</a>  </p></blockquote><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>經典Treap題目。<br>在這題目中，比較棘手的問題是「如何刪除邊」？<br>既然刪除邊非常困難，那我們可以換個角度思考：將操作順序前後顛倒，刪除邊的操作改成新增邊。所以現在就解決了最重要的問題。  </p><p>但是要怎麼merge兩個獨立的Treap？不能使用原本的<code>merge()</code>函數是因為我們不能保證這兩棵獨立的treap之間key值的大小關係。所以這裡需要用到啟發式合併：將小的樹堆所有數字都insert到大的裡面，並且delete掉以釋放空間。<br>啟發式合併的時間複雜度乍看之下很大，但是網路上已經有人證明這種方法複雜度只有到<em>$O(n log_2 n)$</em>，是一個非常好的方法。  </p><p>然後最後一點，在Disjoint set合併的時候，要特別注意是<code>parent[pb] = pa;</code>($|pa| \ge |pb|$)。<br>另外，在查詢的時候，需注意回傳的指標是否為<code>null</code>，否則會導致RE。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: new.cpp</span></span><br><span class="line"><span class="comment">  &gt; Author: Samuel</span></span><br><span class="line"><span class="comment">  &gt; Mail: enminghuang21119@gmail.com</span></span><br><span class="line"><span class="comment">  &gt; Created Time: Fri Aug 17 09:26:25 2018</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">123456789</span>;</span><br><span class="line">    <span class="keyword">return</span> x += (x &lt;&lt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    node *l, *r;</span><br><span class="line">    <span class="keyword">int</span> key, s, pri;</span><br><span class="line">    node()&#123;l = r = <span class="literal">nullptr</span>;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> k): key(k)&#123;l = r = <span class="literal">nullptr</span>; s = <span class="number">1</span>; pri = rand();&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l)</span><br><span class="line">            s += l-&gt;s;</span><br><span class="line">        <span class="keyword">if</span> (r)</span><br><span class="line">            s += r-&gt;s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(node *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a ? a-&gt;s : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">node* root[<span class="number">20010</span>];</span><br><span class="line"><span class="function">node* <span class="title">merge</span><span class="params">(node *a, node *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a || !b)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;pri &lt; b-&gt;pri) &#123;</span><br><span class="line">        a-&gt;r = merge(a-&gt;r, b);</span><br><span class="line">        a-&gt;up();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    b-&gt;l = merge(a, b-&gt;l);</span><br><span class="line">    b-&gt;up();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(node *o, node *&amp;a, node *&amp;b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!o)</span><br><span class="line">        a = b = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;key &lt; k) &#123;</span><br><span class="line">            a = o;</span><br><span class="line">            split(o-&gt;r, a-&gt;r, b, k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            b = o;</span><br><span class="line">            split(o-&gt;l, a, b-&gt;l, k);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;up();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    node *a, *b;</span><br><span class="line">    split(root, a, b, k);</span><br><span class="line">    root = merge(a, merge(<span class="keyword">new</span> node(k), b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(node *&amp;o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!o)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;key == k) &#123;</span><br><span class="line">        node *tmp = o;</span><br><span class="line">        o = merge(o-&gt;l, o-&gt;r);</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node *&amp;next = (o-&gt;key &gt; k ? o-&gt;l : o-&gt;r);</span><br><span class="line">    <span class="keyword">if</span> (erase(next, k))</span><br><span class="line">        <span class="keyword">return</span> o-&gt;up(), <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">kth</span><span class="params">(node *o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!o || k &lt;= <span class="number">0</span> || k &gt; o-&gt;s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (size(o-&gt;r) + <span class="number">1</span> == k)</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    <span class="keyword">if</span> (size(o-&gt;r) &gt;= k)</span><br><span class="line">        <span class="keyword">return</span> kth(o-&gt;r, k);</span><br><span class="line">    <span class="keyword">return</span> kth(o-&gt;l, k - size(o-&gt;r) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_tree</span><span class="params">(node *&amp;o, node *&amp;target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!o)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;l)</span><br><span class="line">        merge_tree(o-&gt;l, target);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;r)</span><br><span class="line">        merge_tree(o-&gt;r, target);</span><br><span class="line">    insert(target, o-&gt;key);</span><br><span class="line">    <span class="keyword">delete</span> o;</span><br><span class="line">    o = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> parent[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == parent[x] ? x : parent[x] = p(parent[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_point</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = p(a);</span><br><span class="line">    b = p(b);</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root[a]-&gt;s &lt; root[b]-&gt;s)</span><br><span class="line">        swap(a, b);</span><br><span class="line">    parent[b] = a;</span><br><span class="line">    merge_tree(root[b], root[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CMD</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;cmd[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">20010</span>];</span><br><span class="line"><span class="keyword">bool</span> connect[<span class="number">60010</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; joint[<span class="number">60010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, q, cas = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">int</span> divid;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        <span class="built_in">memset</span>(connect, <span class="number">0</span>, <span class="keyword">sizeof</span>(connect));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; joint[i].F &gt;&gt; joint[i].S;</span><br><span class="line">        <span class="keyword">for</span> (q = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'E'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'D'</span>)</span><br><span class="line">                connect[a] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'C'</span>)</span><br><span class="line">                    swap(b, w[a]);</span><br><span class="line">            &#125;</span><br><span class="line">            cmd[q++] = &#123;c, a, b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            root[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            insert(root[i], w[i]);</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">if</span> (!connect[i])</span><br><span class="line">                merge_point(joint[i].F, joint[i].S);</span><br><span class="line">        divid = sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            a = cmd[q].a;</span><br><span class="line">            b = cmd[q].b;</span><br><span class="line">            c = cmd[q].c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'D'</span>)</span><br><span class="line">                merge_point(joint[a].F, joint[a].S);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'Q'</span>) &#123;</span><br><span class="line">                divid++;</span><br><span class="line">                <span class="keyword">int</span> pa = p(a);</span><br><span class="line">                node *tmp = kth(root[pa], b);</span><br><span class="line">                sum += tmp ? tmp-&gt;key : <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> pa = p(a);</span><br><span class="line">                erase(root[pa], w[a]);</span><br><span class="line">                insert(root[pa], b);</span><br><span class="line">                w[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; cas++ &lt;&lt; <span class="string">": "</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">6</span>) &lt;&lt;  sum / divid &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;給定一張無向圖，有三種操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;D x   ：刪除第x條邊&lt;/li&gt;
&lt;li&gt;Q x y ：查詢x所在集合裡面第y大的數字，若查詢失敗，則此次查詢的結果為0&lt;/li&gt;
&lt;li&gt;C x y ：將第x點的值改成y&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後輸出所有查詢的平均值。&lt;br&gt;
    
    </summary>
    
      <category term="題解" scheme="http://samuel21119.github.io/categories/%E9%A1%8C%E8%A7%A3/"/>
    
    
      <category term="UVa" scheme="http://samuel21119.github.io/tags/UVa/"/>
    
      <category term="Disjoint set" scheme="http://samuel21119.github.io/tags/Disjoint-set/"/>
    
      <category term="Treap" scheme="http://samuel21119.github.io/tags/Treap/"/>
    
      <category term="Tree" scheme="http://samuel21119.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Template. KMP</title>
    <link href="http://samuel21119.github.io/2018/08/16/Template-KMP/"/>
    <id>http://samuel21119.github.io/2018/08/16/Template-KMP/</id>
    <published>2018-08-16T07:33:03.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>KMP字串比對，回傳第一組子字串的位置。<br>若失敗則回傳-1。<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;T, <span class="keyword">const</span> <span class="built_in">string</span> &amp;P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail(P.size(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt; P.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; P[k] != P[i])</span><br><span class="line">            k = fail[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (P[k] == P[i])</span><br><span class="line">            k++;</span><br><span class="line">        fail[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; T.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; P[k] != T[i])</span><br><span class="line">            k = fail[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (P[k] == T[i])</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">if</span> (k == P.size())</span><br><span class="line">            <span class="keyword">return</span> i - k + <span class="number">1</span>; <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// fail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KMP字串比對，回傳第一組子字串的位置。&lt;br&gt;若失敗則回傳-1。
    
    </summary>
    
      <category term="模板" scheme="http://samuel21119.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="String" scheme="http://samuel21119.github.io/tags/String/"/>
    
      <category term="KMP" scheme="http://samuel21119.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>Template. Heavy-light Decomposition</title>
    <link href="http://samuel21119.github.io/2018/08/15/Template-Heavy-light-Decomposition/"/>
    <id>http://samuel21119.github.io/2018/08/15/Template-Heavy-light-Decomposition/</id>
    <published>2018-08-15T02:54:44.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次DFS，<code>son()</code>：先紀錄所有點的子節點（含）數目、深度等資訊。<br>第二次DFS，<code>build()</code>：依據上次DFS的結果，優先選擇子節點最多的點構成重鏈。<br><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size, max_son, parent, dep;</span><br><span class="line">&#125;n[maxn];</span><br><span class="line"><span class="keyword">int</span> link_top[maxn], link[maxn];</span><br><span class="line"><span class="keyword">int</span> global_time = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">son</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    node &amp;cur = n[now];</span><br><span class="line">    cur.size = <span class="number">1</span>;</span><br><span class="line">    cur.max_son = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : tree[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == p)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        n[i].parent = now;</span><br><span class="line">        n[i].dep = cur.dep + <span class="number">1</span>;</span><br><span class="line">        son(i, now);</span><br><span class="line">        <span class="keyword">if</span> (cur.max_son == <span class="number">-1</span> || n[i].size &gt; n[cur.max_son].size)</span><br><span class="line">            cur.max_son = i;</span><br><span class="line">        cur.size += n[i].size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">    link[now] = ++global_time;</span><br><span class="line">    link_top[now] = top;</span><br><span class="line">    <span class="keyword">if</span> (n[now].size == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    build(n[now].max_son, top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : tree[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n[now].max_son || i == n[now].parent)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        build(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ta = link_top[a];</span><br><span class="line">    <span class="keyword">int</span> tb = link_top[b];</span><br><span class="line">    <span class="keyword">while</span> (ta != tb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n[ta].dep &lt; n[tb].dep) &#123;</span><br><span class="line">            swap(ta, tb);</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        ta = link_top[a = n[ta].parent];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n[a].dep &lt; n[b].dep ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次DFS，&lt;code&gt;son()&lt;/code&gt;：先紀錄所有點的子節點（含）數目、深度等資訊。&lt;br&gt;第二次DFS，&lt;code&gt;build()&lt;/code&gt;：依據上次DFS的結果，優先選擇子節點最多的點構成重鏈。&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://samuel21119.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Tree" scheme="http://samuel21119.github.io/tags/Tree/"/>
    
      <category term="Heavy-light Decomposition" scheme="http://samuel21119.github.io/tags/Heavy-light-Decomposition/"/>
    
      <category term="LCA" scheme="http://samuel21119.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>Template. LCA Doubling Search</title>
    <link href="http://samuel21119.github.io/2018/08/15/Template-LCA-Doubling-Search/"/>
    <id>http://samuel21119.github.io/2018/08/15/Template-LCA-Doubling-Search/</id>
    <published>2018-08-14T22:38:44.000Z</published>
    <updated>2019-02-10T15:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用倍增法的做法來計算LCA。<br>先製作dp表，$dp[i][j]$代表$i$的第$2^j$祖先是誰，若不存在則為-1。<br>在查詢時，先將點$a$和$b$調整到相同高度，再一起慢慢往上移動尋找LCA。<br><em>時間複雜度：$O(N log N)$</em><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"><span class="keyword">int</span> n, logn; <span class="comment">//logn = log2(n) + 1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp[maxn];</span><br><span class="line"><span class="keyword">int</span> deep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logn = log2(n) + <span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    dp[now].resize(logn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; logn; i++)</span><br><span class="line">        dp[now][i] = <span class="number">-1</span>;</span><br><span class="line">    dp[now][<span class="number">0</span>] = parent;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; logn; i++)</span><br><span class="line">        dp[now][i + <span class="number">1</span>] = dp[dp[now][i]][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : tree[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == parent)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        deep[i] = deep[now] + <span class="number">1</span>;</span><br><span class="line">        dfs(i, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &lt; deep[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deep[a] - deep[b], k = <span class="number">0</span>; i; i &gt;&gt;= <span class="number">1</span>, k++)</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">            a = dp[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = logn; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[a][i] != dp[b][i]) &#123;</span><br><span class="line">            a = dp[a][i];</span><br><span class="line">            b = dp[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用倍增法的做法來計算LCA。&lt;br&gt;先製作dp表，$dp[i][j]$代表$i$的第$2^j$祖先是誰，若不存在則為-1。&lt;br&gt;在查詢時，先將點$a$和$b$調整到相同高度，再一起慢慢往上移動尋找LCA。&lt;br&gt;&lt;em&gt;時間複雜度：$O(N log N)$&lt;/em&gt;
    
    </summary>
    
      <category term="模板" scheme="http://samuel21119.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Tree" scheme="http://samuel21119.github.io/tags/Tree/"/>
    
      <category term="LCA" scheme="http://samuel21119.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>Template. Strongly Connect Component</title>
    <link href="http://samuel21119.github.io/2018/08/15/Template-Strongly-Connect-Component/"/>
    <id>http://samuel21119.github.io/2018/08/15/Template-Strongly-Connect-Component/</id>
    <published>2018-08-14T16:11:07.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>point</code>來記錄點的路徑，結果存在<code>result</code>。<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dfs_time = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> visit[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> low[maxn];</span><br><span class="line"><span class="keyword">bool</span> in_stack[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result[maxn]; <span class="comment">//結果存在這裏</span></span><br><span class="line">                  <span class="comment">//result[x]代表x點所在的編號</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; point[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scc</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    visit[now] = low[now] = ++dfs_time;</span><br><span class="line">    sta.push(now);</span><br><span class="line">    in_stack[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : point[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">            scc(i);</span><br><span class="line">        <span class="keyword">if</span> (in_stack[i])</span><br><span class="line">            low[now] = min(low[now], low[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visit[now] == low[now]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            in_stack[tmp = sta.top()] = <span class="number">0</span>;</span><br><span class="line">            sta.pop();</span><br><span class="line">            result[tmp] = id;</span><br><span class="line">        &#125;<span class="keyword">while</span> (tmp != now);</span><br><span class="line">        id++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;point&lt;/code&gt;來記錄點的路徑，結果存在&lt;code&gt;result&lt;/code&gt;。
    
    </summary>
    
      <category term="模板" scheme="http://samuel21119.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Tarjan Algorithm" scheme="http://samuel21119.github.io/tags/Tarjan-Algorithm/"/>
    
      <category term="SCC" scheme="http://samuel21119.github.io/tags/SCC/"/>
    
  </entry>
  
  <entry>
    <title>Template. Treap</title>
    <link href="http://samuel21119.github.io/2018/08/14/Template-Treap/"/>
    <id>http://samuel21119.github.io/2018/08/14/Template-Treap/</id>
    <published>2018-08-13T16:13:12.000Z</published>
    <updated>2019-01-31T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Treap = Heap + Tree。</p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><ul><li>宣告：<br><code>treap&lt;型別&gt; a, b;</code></li><li>插入：<br><code>a.insert(100);</code></li><li>刪除：<br><code>a.erase(100);</code></li><li>查詢第k大（回傳node指標，取<code>-&gt;key</code>即可得到該數字）：<br><code>a.kth(1);</code></li><li>查詢某數為第幾大（0為第一個）：<br><code>a.rank(100);</code><a id="more"></a></li></ul><h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">123456789</span>;</span><br><span class="line">    <span class="keyword">return</span> x += (x &lt;&lt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        node *l, *r;</span><br><span class="line">        T key;</span><br><span class="line">        <span class="keyword">int</span> pri, size;</span><br><span class="line">        node(T k):key(k) &#123;</span><br><span class="line">            l = r = <span class="literal">nullptr</span>;</span><br><span class="line">            pri = rand();</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l)</span><br><span class="line">                size += l-&gt;size;</span><br><span class="line">            <span class="keyword">if</span> (r)</span><br><span class="line">                size += r-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(node *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node* <span class="title">merge</span><span class="params">(node *a, node *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a || !b)</span><br><span class="line">            <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;pri &lt; b-&gt;pri) &#123;</span><br><span class="line">            a-&gt;r = merge(a-&gt;r, b);</span><br><span class="line">            a-&gt;up();</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        b-&gt;l = merge(a, b-&gt;l);</span><br><span class="line">        b-&gt;up();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(node *R, node *&amp;a, node *&amp;b, T k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!R)</span><br><span class="line">            a = b = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (R-&gt;key &lt; k) &#123;</span><br><span class="line">            a = R;</span><br><span class="line">            split(R-&gt;r, a-&gt;r, b, k);</span><br><span class="line">            R-&gt;up();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            b = R;</span><br><span class="line">            split(R-&gt;l, a, b-&gt;l, k);</span><br><span class="line">            R-&gt;up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;Root, T k)</span> </span>&#123;</span><br><span class="line">        node *a, *b;</span><br><span class="line">        split(Root, a, b, k);</span><br><span class="line">        Root = merge(a, merge(<span class="keyword">new</span> node(k), b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(node *&amp;R, T k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!R)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (R-&gt;key == k) &#123;</span><br><span class="line">            node *tmp = R;</span><br><span class="line">            R = merge(R-&gt;l, R-&gt;r);</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node *&amp;nxt = R-&gt;key &gt; k ? R-&gt;l : R-&gt;r;</span><br><span class="line">        <span class="keyword">if</span> (erase(nxt, k)) &#123;</span><br><span class="line">            R-&gt;up();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split2</span><span class="params">(node *R, node *&amp;a, node *&amp;b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!R)</span><br><span class="line">            a = b = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= size(R-&gt;l) + <span class="number">1</span>) &#123;</span><br><span class="line">                a = R;</span><br><span class="line">                split2(R-&gt;r, a-&gt;r, b, k - size(R-&gt;l) - <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                b = R;</span><br><span class="line">                split2(R-&gt;l, a, b-&gt;l, k);</span><br><span class="line">            &#125;</span><br><span class="line">            R-&gt;up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Simple way to use:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T k)</span> </span>&#123;</span><br><span class="line">        insert(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(T k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> erase(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(T k)</span> </span>&#123;</span><br><span class="line">        node *a, *b;</span><br><span class="line">        split(root, a, b, k);</span><br><span class="line">        <span class="keyword">int</span> re = size(a);</span><br><span class="line">        root = merge(a, b);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node* <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        node *a, *b, *c;</span><br><span class="line">        a = b = c = <span class="literal">nullptr</span>;</span><br><span class="line">        split2(root, a, c, k);</span><br><span class="line">        split2(a, a, b, k - <span class="number">1</span>);</span><br><span class="line">        root = merge(merge(a, b), c);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">treap&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">t.insert(<span class="number">1</span>);</span><br><span class="line">t.insert(<span class="number">2</span>);</span><br><span class="line">t.insert(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.kth(<span class="number">3</span>)-&gt;key &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.rank(<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Treap = Heap + Tree。&lt;/p&gt;
&lt;h1 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;宣告：&lt;br&gt;&lt;code&gt;treap&amp;lt;型別&amp;gt; a, b;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插入：&lt;br&gt;&lt;code&gt;a.insert(100);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;刪除：&lt;br&gt;&lt;code&gt;a.erase(100);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查詢第k大（回傳node指標，取&lt;code&gt;-&amp;gt;key&lt;/code&gt;即可得到該數字）：&lt;br&gt;&lt;code&gt;a.kth(1);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查詢某數為第幾大（0為第一個）：&lt;br&gt;&lt;code&gt;a.rank(100);&lt;/code&gt;
    
    </summary>
    
      <category term="模板" scheme="http://samuel21119.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Treap" scheme="http://samuel21119.github.io/tags/Treap/"/>
    
      <category term="Tree" scheme="http://samuel21119.github.io/tags/Tree/"/>
    
      <category term="Persistence" scheme="http://samuel21119.github.io/tags/Persistence/"/>
    
  </entry>
  
</feed>
